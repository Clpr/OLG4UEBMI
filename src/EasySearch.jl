__precompile__()
"""
    EasySearch

searching steady states & transition path;
concise design;
requires modules/packages in LOAD_PATH
"""
module EasySearch
    import House  # household life-cycle optimization problems
    import EasyEcon  # economic functions, e.g. CD production function
    import EasyMath: vecExpand, diagr, diagw!  # generalized mathematical and linear-algebra methods


# ==============================================================================
## SECTION 0: Assistant Functions è¾…åŠ©å‡½æ•°
# NOTE: in this section, we define some assistant functions which are used in searching
#       æœ¬èŠ‚æˆ‘ä»¬å®šä¹‰ä¸€æ‰¹åœ¨æ±‚è§£æ—¶å¾ˆæœ‰ç”¨çš„è¾…åŠ©å‡½æ•°
#       they are:
#       1. SummaryYear(), prints a summary of the search of steady states
#       2. SummaryTransition(), prints a summary of the search of transition path
#       3. DatSlice4Household(), slices data packages for the life-cycle optimization problem of household department
# --------------
    """
        SummaryYear( t::Int, Dt::Dict, Dst::Dict, Pt::Dict, Ps::Dict, S::Int, Sr::Int )

    Summarizes a specific cross-sectional; usually used in the summary of steady states;
    It returns nothing but prints to console;
    """
    function SummaryYear( t::Int, Dt::Dict, Dst::Dict, Pt::Dict, Ps::Dict, S::Int, Sr::Int )
        println("\t","."^40, " Factor Markets")
        println("\t+ Aggregated Capital: ", Dt[:K][t] )
        println("\t+ Aggregated Labor  : ", Dt[:L][t] )
        println("\t+ Net Intereste Rate: ", Dt[:r][t] )
        println("\t+ Average Wage Level: ", Dt[:wÌ„][t] )
        println("\t","-"^40, " Good Market")
        println("\t+ GDP               : ", Dt[:Y][t] )
        println("\t+ C, I, G           : ", [ Dt[:C][t], Dt[:I][t], Dt[:G][t] ]  )
        println("\t+ C, I, G Shares    : ", [ Dt[:C][t], Dt[:I][t], Dt[:G][t] ] ./ (Dt[:Y][t] + eps())  )
        println("\t","."^40, " General Fiscal")
        println("\t+ TaxRev Consumption: ", Dt[:TRc][t] )
        println("\t+ TaxRev Wage Income: ", Dt[:TRw][t] )
        println("\t+ Debt & Debt/GDP   : ", [ Dt[:D][t], Dt[:D2Y][t] ] )
        println("\t","."^40, " PAYG Pension")
        println("\t+ Benefit Amount    : ", Dt[:Î›][t] )
        println("\t+ Substitution Rate : ", Dt[:Î›][t] / (Dt[:wÌ„][t] * Dt[:L][t] / sum(Ps[:N][t, 1:Sr]) + eps())  )
        println("\t","."^40, " UE-BMI")
        println("\t+ Gap of Pooling Acc: ", Dt[:LI][t] )
        println("\t+ Gap/GDP           : ", Dt[:LI][t] / (Dt[:Y][t] + eps()) )
        println("\t+ Gap/TaxRev        : ", Dt[:LI][t] / (Dt[:TRc][t] + Dt[:TRw][t] + eps()) )
        println("\t","."^40, " Household Department")
        println("\t+ Agg Wealth : ", sum(Ps[:N][t, 1:S] .* Dst[:ğ’œ][t, 1:S]) )
        println("\t+ Agg Personal Asset: ", sum(Ps[:N][t, 1:S] .* Dst[:a][t, 1:S]) )
        println("\t+ Agg UEBMI Indi-Acc: ", sum(Ps[:N][t, 1:S] .* Dst[:Î¦][t, 1:S]) )
        println("\t+ Max Wealth & Loc  : ", findmax(Dst[:ğ’œ][t, 1:S]) )  # prepared for possible DP, which can help check if DP works well
        println("\t","-"^40)

        return nothing
    end
    # ------------------------------
    """
    DatSlice4Household( t::Int, Dt::Dict, Dst::Dict, Pt::Dict, Ps::Dict ; S::Int = 80, Sr::Int = 40, a1::Float64 = 0.0, Î¦1::Float64 = 0.0, SearchType::String = "SteadyState" )

    Slices data, generates a Dict **d** for LifeDecision() in EasyHousehold module (just input **Pc** to LifeDecision());
    based on data collections generated by proc_InitPars.jl & proc_VarsDeclare.jl;
    the String parameter **SearchType** controls the type of data slices. It should be one of:
    1. "SteadyState":  The Search of Steady State (S > Sr > 1), i.e. starting from s = 1
    2. "AliveInYear0Working": For those alive in initial steady state but re-optimize working & retired paths in year 1 (S > Sr >= 1)

    The function now can automatically handle the case that there are several years toching possible final steady state;
    returns a Dict **OriginData**.

    ç”¨äºä¸ºç¨³æ€ã€è½¬è½¨è·¯å¾„çš„å®¶æˆ·æœ€ä¼˜å†³ç­–é—®é¢˜åˆ‡ç‰‡æ•°æ®ï¼›å·²ç»èƒ½å¤Ÿè‡ªåŠ¨é›†ä¸­å¤„ç†å„ç±»å¼‚å¸¸ï¼ˆå°¤å…¶æ˜¯touchåˆ°æœ€ç»ˆç¨³æ€æ—¶çš„æ•°æ®æ‹“å±•é—®é¢˜ï¼‰

    # Depends on:
    1. EasyMath.vecExpand() : expand vectors for those born in laste years of transition path. some years of these men have reached the final steady state
    2. EasyMath.diagr(): read diagonal elements from a matrix, automatically add/drop extra elements
    """
    function DatSlice4Household( t::Int, Dt::Dict, Dst::Dict, Pt::Dict, Ps::Dict, Pc::Dict, env::NamedTuple ;
        S::Int = 80, Sr::Int = 40, a1::Float64 = 0.0, Î¦1::Float64 = 0.0,
        SearchType::String = "SteadyState" )
        # ----------------------
        local OriginData = Dict{Symbol,Union{Float64,Int,Vector{Float64}}}()  # use strict type assertions

        if SearchType == "SteadyState"
        # CASE 1: The Search of Steady State (S > Sr >= 1), i.e. starting from s = 1
        # CASE 1: æœç´¢ç¨³æ€ï¼ˆS > Sr >= 1),å³ä»å‡ºç”Ÿå¼€å§‹åˆ°æ­»
        # NOTE: :t now indicates which year to search steady state on
            # assert: S > Sr > 1
            @assert( S > Sr > 1, "requiring: S > Sr > 1; CASE SteadyState" )
            # --------- Constants
            OriginData[:Smax] = S; OriginData[:Sret] = Sr
            OriginData[:alpha] = Pc[:Î±]; OriginData[:gamma] = Pc[:Î³]
            OriginData[:k1] = a1 + Î¦1
            # --------- Constants in this paper but converted to vectors in a standard problem
            OriginData[:Ïƒ] = fill( Pc[:Ïƒ] , Sr )
            OriginData[:Î¼] = fill( Pc[:Î¼] , S  )
            OriginData[:Î´] = fill( Pc[:Î´] , S  )
            # --------- Vectors
                # -------- len = S
            OriginData[:Survival] = 1.0 .- Ps[:F][t,1:S] # Survival probs
            OriginData[:q] = fill(Pt[:q][t],S) # m2c ratio, the ratio of health expenditure on consumption
            OriginData[:r] = fill(Dt[:r][t],S) # interest rates
            OriginData[:cpB] = fill(Pt[:cpB][t],S) # co-payment rate of inpatient expenditure
            OriginData[:p] = Ps[:p][1:S] # MA/MB ratio
                # -------- len = Sr
            OriginData[:w] = Dst[:w][t,1:Sr] # wage level
            OriginData[:z] = fill(Pt[:z][t],Sr) # collection rate of pension
            OriginData[:Ï•] = fill(Pt[:Ï•][t],Sr) # contribution: agent â†’ UEBMI
            OriginData[:Î¶] = fill(Pt[:Î¶][t],Sr) # contribution: firm â†’ UEBMI
            OriginData[:Î·] = fill(Pt[:Î·][t],Sr) # contribution: firm â†’ pension
            OriginData[:Î¸] = fill(Pt[:Î¸][t],Sr) # contribution: agent â†’ pension
            OriginData[:ğ•’] = fill(Pt[:ğ•’][t],Sr) # transfer rate from firm contribution of UEBMI to working agents
                # -------- len = S - Sr
            OriginData[:Î›] = fill(Dt[:Î›][t],S-Sr) # pension benefit amounts
            OriginData[:ğ•¡] = fill(Dt[:ğ•¡][t],S-Sr) # transfer amounts from firm contribution of UEBMI to retired generations

        elseif SearchType == "AliveInYear0Working"
        # CASE 2: For those alive in initial steady state but re-optimize working & retired paths in year 1 (S > Sr >= 1)
        # CASE 2: ä¸ºé‚£äº›åœ¨åˆå§‹ç¨³æ€æ—¶ä»å­˜æ´»ä¸”ã€è¿˜æœªã€‘é€€ä¼‘çš„äººï¼Œè¿™äº›äººç”±äºç¬¬1å¹´çš„å†²å‡»ä¼šé‡æ–°å†³ç­–å‰©ä¸‹å¹´å²é‡Œçš„èµ„äº§ã€æ¶ˆè´¹ã€åŠ³åŠ¨ï¼›æ­¤æ—¶æœ‰ S > Sr >= 1
        # NOTE: now, Sr is the left years of working, and S is the left years to live!
        # NOTE: using the REAL :S in :env to locate the starting years (to slice data from our data packages)
        #       ä½¿ç”¨envç¯å¢ƒå˜é‡Tupleé‡ŒçœŸæ­£çš„æœ€å¤§å¹´é¾„env.Sæ¥ç¡®å®šæ­¤æ—¶å‡ºå‘çš„çœŸæ­£ä½ç½®ï¼ˆç”¨äºåœ¨çŸ©é˜µé‡Œå–æ•°æ®ï¼‰
        # NOTE: the principle to compute offset= : è®¡ç®—diagrçš„offsetå‚æ•°çš„è§„åˆ™
        #       Princp: the agent is s=2 years old at the BEGINNING of year 1 (Steady State)
        #               he/she at most lives for S=4 years (dies at the END of age 4);
        #               and both shock & life-cycle-re-optimization happens at the BEGINNING of year 1;
        #               Therefore, he/she has S`=3=S-s+1 years to live, i.e. the :S parameter in this function;
        #               to slice his/her data, we need an offset=s-1=1, i.e. offset=S-S`
        #       Formula: s = S - S` + 1
        # NOTE: in fact, this formula assumes that we always slice data from the top row of matrix data structures! (i.e. CASE 2,3 ONLY works for the search of first years of transition path!)
        #       äº‹å®ä¸Šï¼Œä½¿ç”¨è¿™æ ·ä¸€ä¸ªå…¬å¼æ„å‘³ç€CASE 2,3åªèƒ½ç”¨äºæœç´¢è½¬è½¨è·¯å¾„çš„æœ€å¼€å§‹å‡ å¹´ï¼ï¼ˆå› ä¸ºå®ƒæ„å‘³ç€æ€»æ˜¯ä»çŸ©é˜µçš„ç¬¬ä¸€è¡Œï¼Œæœ€é¡¶ç«¯å¼€å§‹å–å€¼ï¼‰
        # NOTE: some lines are specially tendented to indicate that they are specially modified !
        # --------------------
            # assert  S > Sr >= 1
            @assert( S > Sr >= 1, "requiring: S > Sr >= 1; CASE AliveInYear0Working" )
            # --------- Constants
            OriginData[:Smax] = S; OriginData[:Sret] = Sr
            OriginData[:alpha] = Pc[:Î±]; OriginData[:gamma] = Pc[:Î³]
            OriginData[:k1] = a1 + Î¦1
            # --------- Constants in this paper but converted to vectors in a standard problem
            OriginData[:Ïƒ] = fill( Pc[:Ïƒ] , Sr )
            OriginData[:Î¼] = fill( Pc[:Î¼] , S  )
            OriginData[:Î´] = fill( Pc[:Î´] , S  )
            # --------- Vectors
                # -------- len = S
                OriginData[:Survival] = 1.0 .- diagr(Ps[:F], offset = env.S - S , LEN = S)  # please refer to the notes of this CASE
            OriginData[:q] = vecExpand(Pt[:q][t:end], S) # m2c ratio
            OriginData[:r] = vecExpand(Dt[:r][t:end], S) # interest rates
            OriginData[:cpB] = vecExpand(Pt[:cpB][t:end], S) # co-payment rate of inpatient expenditure
                OriginData[:p] = Ps[:p][env.S-S+1:env.S] # NOTE: s -> real maximum age
                # -------- len = Sr
                OriginData[:w] = diagr(Dst[:w], offset = env.S - S, LEN = Sr) # wage, (sliced)
            OriginData[:z] = vecExpand(Pt[:z][t:end], Sr) # collection rate of pension
            OriginData[:Ï•] = vecExpand(Pt[:Ï•][t:end], Sr) # contribution: agent â†’ UEBMI
            OriginData[:Î¶] = vecExpand(Pt[:Î¶][t:end], Sr) # contribution: firm â†’ UEBMI
            OriginData[:Î·] = vecExpand(Pt[:Î·][t:end], Sr) # contribution: firm â†’ pension
            OriginData[:Î¸] = vecExpand(Pt[:Î¸][t:end], Sr) # contribution: agent â†’ pension
            OriginData[:ğ•’] = vecExpand(Pt[:ğ•’][t:end], Sr) # transfer rate from firm contribution of UEBMI to working agents
                # -------- len = S - Sr
            OriginData[:Î›] = vecExpand(Dt[:Î›][t:end], S-Sr) # pension benefit amounts
            OriginData[:ğ•¡] = vecExpand(Dt[:ğ•¡][t:end], S-Sr) # transfer amounts from firm contribution of UEBMI to retired generations

        elseif SearchType == "AliveInYear0Retired"
        # CASE 3: For those alive in initial steady state but re-optimize ONLY retired paths in year 1 (S >= 1)
        #         ä¸ºé‚£äº›åœ¨åˆå§‹ç¨³æ€æ—¶ä»å­˜æ´»ä¸”ã€å·²ç»ã€‘é€€ä¼‘çš„äººï¼Œè¿™äº›äººç”±äºç¬¬1å¹´çš„å†²å‡»ä¼šé‡æ–°å†³ç­–å‰©ä¸‹å¹´å²é‡Œçš„èµ„äº§ã€æ¶ˆè´¹ã€åŠ³åŠ¨ï¼›æ­¤æ—¶æœ‰ S >= 1
        # NOTE: now, Sr is no more required, and S is the left years to live!
        # NOTE: using the REAL :S in :env to locate the starting years (to slice data from our data packages)
        #       ä½¿ç”¨envç¯å¢ƒå˜é‡Tupleé‡ŒçœŸæ­£çš„æœ€å¤§å¹´é¾„env.Sæ¥ç¡®å®šæ­¤æ—¶å‡ºå‘çš„çœŸæ­£ä½ç½®ï¼ˆç”¨äºåœ¨çŸ©é˜µé‡Œå–æ•°æ®ï¼‰
        # NOTE: the principle to compute offset= is the same as that of CASE 2 è®¡ç®—diagrçš„offsetå‚æ•°çš„è§„åˆ™å’Œä¸Šä¸€ç§CASEç›¸åŒ
        # -----------
            # assert  S >= 1
            @assert( S >= 1, "requiring: S > Sr >= 1; CASE AliveInYear0Retired" )
            # --------- Constants
            OriginData[:Smax] = S
            OriginData[:alpha] = Pc[:Î±]; OriginData[:gamma] = Pc[:Î³]
            OriginData[:k1] = a1 + Î¦1
            # --------- Constants in this paper but converted to vectors in a standard problem
            OriginData[:Î¼] = fill( Pc[:Î¼] , S  )
            OriginData[:Î´] = fill( Pc[:Î´] , S  )
            # --------- Vectors
                # -------- len = S
                OriginData[:Survival] = 1.0 .- diagr(Ps[:F], offset = env.S - S , LEN = S)  # please refer to the notes of this CASE
            OriginData[:q] = vecExpand(Pt[:q][t:end], S)
            OriginData[:r] = vecExpand(Dt[:r][t:end], S)
            OriginData[:cpB] = vecExpand(Pt[:cpB][t:end], S)
                OriginData[:p] = Ps[:p][env.S-S+1:env.S] # NOTE: s -> real maximum age
                # -------- len = S (NOTE: :S is the left years to live!, and the indices of Î› & ğ•¡ have been changed)
                OriginData[:Î›] = vecExpand(Dt[:Î›][t:end], S )
                OriginData[:ğ•¡] = vecExpand(Dt[:ğ•¡][t:end], S )

        elseif SearchType == "BornInTransition"
        # CASE 4: For those born in transition path (including those who have reached final steady state before natural death)
        #         ä¸ºé‚£äº›åœ¨è½¬è½¨è·¯å¾„ä¸Šå‡ºç”Ÿçš„äººï¼ˆåŒ…æ‹¬æœ‰æŸäº›å¹´å·²ç»åˆ°äº†æœ€ç»ˆç¨³æ€çš„é‚£äº›äººï¼‰
        # NOTE: now, we always compute FULL life-cycle paths, i.e. S > Sr >= 1 must be satisfied
        #       ç°åœ¨æˆ‘ä»¬æ€»æ˜¯è®¡ç®—å®Œæ•´çš„ç”Ÿå‘½æœŸæ¶ˆè´¹åŠ³åŠ¨èµ„äº§ç­‰è·¯å¾„ï¼Œå¿…æœ‰S>Sr>=1æˆç«‹
        #       and, because we use special-designed functions EasyMath.vecExpand() & EasyMath.diagr()
        #       å¹¶ä¸”ï¼Œç”±äºæˆ‘ä»¬ä½¿ç”¨äº†ç‰¹åˆ«è®¾è®¡çš„ä¸¤ä¸ªå‡½æ•°
        #       the function can automatically construct full-length vectors for those who have reached final steady state before natural death
        #       æˆ‘ä»¬å¯ä»¥è‡ªåŠ¨æ„å»ºå…¨é•¿åº¦çš„æ•°æ®å‘é‡ï¼Œä¸ºé‚£äº›åœ¨æ­»ä¹‹å‰å°±å·²ç»åˆ°è¾¾æœ€ç»ˆç¨³æ€çš„äºº(i.e. t_born + S > T_max)
        #       where actually in our data structures, the years after T_max (the moment reaching final steady state) are not saved
        #       è¿™æ ·è®¾è®¡æ˜¯å› ä¸ºåœ¨æˆ‘ä»¬çš„æ•°æ®ç»“æ„é‡Œï¼Œå½“åˆ°è¾¾æœ€ç»ˆç¨³æ€å³è¶…è¿‡æœ€å¤§å¹´æ•°Tï¼ˆè½¬è½¨è·¯å¾„é•¿åº¦ï¼‰ä¹‹åçš„æ•°æ®å¹¶ä¸ä¼šç‰¹åˆ«å‚¨å­˜ï¼ˆå› ä¸ºå®ƒä»¬å’Œæœ€ç»ˆç¨³æ€ä¸€æ ·ï¼‰
        # NOTE: different from CASE 2,3, we use a different principle to determine the offset= in diagr()
        #       ä¸åŒäºCASE 2,3ï¼Œæˆ‘ä»¬ç°åœ¨ä½¿ç”¨ä¸åŒçš„è§„åˆ™æ¥å†³å®šdiagr()ä¸­offset=å‚æ•°çš„å€¼ï¼š
        #       Principle: offset = 1 - t, where t is the year when agents born, t = 1,...,T
        # -----------
            # assert  S > Sr >= 1
            @assert( S > Sr >= 1, "requiring: S > Sr >= 1; CASE AliveInYear0Working" )
            # --------- Constants
            OriginData[:Smax] = S; OriginData[:Sret] = Sr
            OriginData[:alpha] = Pc[:Î±]; OriginData[:gamma] = Pc[:Î³]
            OriginData[:k1] = a1 + Î¦1
            # --------- Constants in this paper but converted to vectors in a standard problem
            OriginData[:Ïƒ] = fill( Pc[:Ïƒ] , Sr )
            OriginData[:Î¼] = fill( Pc[:Î¼] , S  )
            OriginData[:Î´] = fill( Pc[:Î´] , S  )
            # --------- Vectors
                # -------- len = S
                OriginData[:Survival] = 1.0 .- diagr(Ps[:F], offset = 1 - t, LEN = S)
            OriginData[:q] = vecExpand(Pt[:q][t:end], S) # m2c ratio
            OriginData[:r] = vecExpand(Dt[:r][t:end], S) # interest rates
            OriginData[:cpB] = vecExpand(Pt[:cpB][t:end], S) # co-payment rate of inpatient expenditure
                OriginData[:p] = Ps[:p][env.S-S+1:env.S] # NOTE: s -> real maximum age
                # -------- len = Sr
                OriginData[:w] = diagr(Dst[:w], offset = 1 - t, LEN = Sr) # wage, (sliced)
            OriginData[:z] = vecExpand(Pt[:z][t:end], Sr) # collection rate of pension
            OriginData[:Ï•] = vecExpand(Pt[:Ï•][t:end], Sr) # contribution: agent â†’ UEBMI
            OriginData[:Î¶] = vecExpand(Pt[:Î¶][t:end], Sr) # contribution: firm â†’ UEBMI
            OriginData[:Î·] = vecExpand(Pt[:Î·][t:end], Sr) # contribution: firm â†’ pension
            OriginData[:Î¸] = vecExpand(Pt[:Î¸][t:end], Sr) # contribution: agent â†’ pension
            OriginData[:ğ•’] = vecExpand(Pt[:ğ•’][t:end], Sr) # transfer rate from firm contribution of UEBMI to working agents
                # -------- len = S - Sr
            OriginData[:Î›] = vecExpand(Dt[:Î›][t:end], S-Sr) # pension benefit amounts
            OriginData[:ğ•¡] = vecExpand(Dt[:ğ•¡][t:end], S-Sr) # transfer amounts from firm contribution of UEBMI to retired generations

        else
        # CASE : wrong SearchType= input
            throw(ErrorException("in valid keyword parameter SearchType=, please use one of : SteadyState, BornInTransition, AliveInYear0Retired, AliveInYear0Working"))
        end

        # return
        return OriginData::Dict
    end
    # ----------------





# ==============================================================================
## SECTION 1: Steady State ç¨³æ€ï¼ˆé•¿æœŸå‡è¡¡ï¼‰æœç´¢
# NOTE: in this section, we define an in-place function SteadyState!(t)
#       æœ¬èŠ‚æˆ‘ä»¬å®šä¹‰ä¸€ä¸ªç›´æ¥ä½œç”¨äºæ•°æ®åŒ…ä¸Šçš„å‡½æ•°SteadyState!(t)
#       this function searches steady states (SS) based on input datasets, where t is the year to search a steady state
#       è¿™ä¸ªå‡½æ•°åŸºäºè¾“å…¥çš„æ•°æ®é›†ï¼Œåœ¨ç‰¹å®šå¹´ä¸Šæœç´¢ç¨³æ€(SS)
#       the results are made through modifying :Dt & :Dst
#       æœç´¢ç»“æœç›´æ¥åæ˜ åœ¨Dtå’ŒDstè¿™ä¸¤ä¸ªæ•°æ®åŒ…é‡Œï¼Œç›´æ¥ä¿®æ”¹è€Œä¸æ˜¯è¿”å›æ–°çš„æ•°æ®åŒ…
#       this kind of design allows us to simutaneously solve multiple different models which are defined by data
#       è¿™æ ·çš„è®¾è®¡å…è®¸æˆ‘ä»¬åŒæ—¶æ±‚è§£ä¸€æ½å­å‚æ•°/æ•°æ®ä¸åŒçš„æ¨¡å‹
# --------------
    """
        SteadyState!( t::Int, Guess::NamedTuple, Dt::Dict, Dst::Dict, Pt::Dict, Ps::Dict, Pc::Dict, env::NamedTuple ; atol::Float64 = 1E-8, MaxIter::Int = 100, PrintMode::String = "full", MagicNum::Real = 2.0, StepLen::Real = 0.5 )

    Searches steady state on a specific **t** slice, using guesses of interest rate & labor (**Guess**);
    the results will be directly/in-place written in data collections (**Dt**, **Dst**);
    returns nothing.

    ## Inputs:
    1. t : the year to search steady state on, it should be less than or equal to *env.MAX_YEAR*
    2. Guess : a NamedTuple consisting of two elements: ( r = interest rate in digits, L = labor factor )
    3. Dt : a data collection to modify/write, containing year data; defined in proc_VarsDeclare
    4. Dst : a data collection to modify/write, containing age Ã— year data; defined in proc_VarsDeclare
    5. env : a parameter collection containing basic parameters like MAX_AGE, RETIRE_AGE and others
    6. Pt : a parameter collection containing year data, won't be modified
    7. Ps : a parameter collection containing age specific data & demographic data (population & mortality); won't be modified
    8. Pc : a parameter collection containing constant data, won't be modified
    9. atol : tolerance of Gauss-Seidel iteration
    10. MaxIter : maximum loops
    11. PrintMode : a string to decide how to display results & loop information
        1. "full" : print all information, including round, error, summary of economy in each round; print a detailed summary when exit
        2. "concise" : print round, error, but no summary of economy for each round; print a detailed summary when ends
        3. "final": print nothing for each round; print a detailed summary when iteration ends
        4. "silent" : nothing printed for each round; nothing printed when iteration ends
    12. MagicNum : a lower bound of capital per labor (K/L) to prevent divergence out of interest rate (a function of capital per labor)
    13. StepLen : relative step length to update guesses of Gauss-Seidel algorithm, in range (0,1]

    ## Modified:
    1. Dt: update economic variables (e.g. GDP, interest rate)
    2. Dst: update consumption, labor and other age-specific data

    ## Iteration Steps:
    1. Firm department
    2. Pension
    3. Household problems
    4. Fiscal, Aggregation & Update

    ## Depends on:
    1.

    """
    function SteadyState!( t::Int, Guess::NamedTuple, Dt::Dict, Dst::Dict,
        Pt::Dict, Ps::Dict, Pc::Dict, env::NamedTuple ;
        atol::Float64 = 1E-8,  # tolerance of Gauss-Seidel iteration
        MaxIter::Int = 100,  # maximum loops
        PrintMode::String = "full",  # mode of printing, one of ["full","concise","final","silent"]
        MagicNum::Real = 2.0,  # magic number, the lower bound of K/L (capital per labor)
        StepLen::Real = 0.5  # relative step length to update guesses, in range (0,1]
    )
        ## Section: validation
        @assert( 0 < t <= env.T , string("t not in range [1, ",env.T,"], received :",t) )
        @assert( isa(Guess.r, Real) & (Guess.L > 0.0), "please check your Guess::NamedTuple" )  # simutaneously check existence of r, L in Guess and their range
        @assert( PrintMode in ["full","concise","final","silent"] , "undefined PrintMode string" )
        @assert( 0.0 < StepLen <= 1.0 , "invalid StepLen, it should be in range (0,1]" )
        @assert( MagicNum > 0.0 , "invalid MagicNum (capital per capita) which must be greater than 0" )
        Ps[:F][t,env.S] = 0.0  # forcely refresh mortality in the very last year å¼ºåˆ¶åˆ·æ–°æœ€åä¸€å²çš„æ­»äº¡ç‡ä¸º0
        ## Section: malloc å†…å­˜é¢„åˆ†é…
        local tmpK1::Float64, tmpK2::Float64  # temporary variables of capital factor in iterations
        local tmpL1::Float64, tmpL2::Float64  # temporary variables of labor factor
            tmpL1 = Guess.L  # save the guess of aggregated labor (initialization)
            Dt[:r][t] = Guess.r  # save the guess of interest rate (initialiation)
        ## Section: intermediate variables & abbreviations å¿«æ·å˜é‡
        local tmpVal::Float64 = 1.0 + Pt[:z][t] * Pt[:Î·][t] + Pt[:Î¶][t] # a temporary variable
        local Ï€Coef::Float64 = Pt[:z][t] * (Pt[:Î¸][t] + Pt[:Î·][t]) / tmpVal # total contribution to pension (on nomial wage level)
        local Ï€Mf::Float64 = Pt[:Î¶][t] / tmpVal # firm contribution rate to UE-BMI
        local Ï€Mp::Float64 = Pt[:Ï•][t] / tmpVal # employee/personal contribution rate to UE-BMI
        local Ï€M = Ï€Mf + Ï€Mp # total contribution rate to UE-BMI on nomial wage level
        ## Section: fill labor with an even distribution to initialize labor ä½¿ç”¨å¹³å¦çš„åŠ³åŠ¨åŠ›åˆ†å¸ƒå¡«å……ä»¥åˆå§‹åŒ–
        Dst[:Lab][t,1:env.Sr] .= tmpL1 / env.Sr

        ## Section: Gauss-Seidel Iterations
        for idx in 1:MaxIter
            # SubSection 1: firm department å‚å•†éƒ¨é—¨
                # 1. production function & firm optimal decisions ç”Ÿäº§å‡½æ•° & å‚å•†æœ€ä¼˜å†³ç­–
                if idx == 1   # NOTE: use interest rate & labor to get capital in the first round  ç¬¬ä¸€è½®ä½¿ç”¨åˆ©ç‡å’ŒåŠ³åŠ¨åŠ›åæ¨å‡ºèµ„æœ¬å­˜é‡
                    tmpK1 = tmpL1 * ( (Guess.r + Pc[:Îº]) / (Pt[:Î²][t] * Pt[:A][t]) ) ^ (1.0 / (Pt[:Î²][t] - 1.0))
                    @assert( tmpK1 > 0.0 , string("negative K found in round: ", idx) ) # check capital
                    Dt[:Y][t], tmpVal, Dt[:wÌ„][t] = EasyEcon.CDProdFunc( Pt[:A][t], tmpK1, tmpL1, Pt[:Î²][t], Îº = Pc[:Îº], GetPrice = true, TechType = "Hicks"  ) # optimal decision æœ€ä¼˜å†³ç­–ï¼Œè¿”å›ä»·æ ¼
                else
                    Dt[:Y][t], Dt[:r][t], Dt[:wÌ„][t] = EasyEcon.CDProdFunc( Pt[:A][t], tmpK1, tmpL1, Pt[:Î²][t], Îº = Pc[:Îº], GetPrice = true, TechType = "Hicks"  ) # optimal decision æœ€ä¼˜å†³ç­–ï¼Œè¿”å›ä»·æ ¼
                end
                # 2. wage profiling å·¥èµ„æ›²çº¿
                Dst[:w][t,:], Dt[:o][t] = EasyEcon.WageProfile( Dt[:wÌ„][t], Ps[:Îµ][1:env.Sr], Ps[:N][t,1:env.Sr], Dst[:Lab][t,1:env.Sr], GetScalingCoef = true  )

            # SubSection 2: PAYG pension benefits å…»è€é‡‘ç»™ä»˜
                Dt[:Î›][t] = EasyEcon.PAYGPension( Ï€Coef, Dst[:w][t,:], Ps[:N][t,:], Dst[:Lab][t,:], env.Sr )
            # SubSection 3: average transfer amount from firm medical contribution to retired generations å½“æœŸä¼ä¸šåŒ»ä¿ç¼´çº³å¯¹é€€ä¼‘äººå‘˜çš„å¹³å‡è¡¥è´´é‡
                Dt[:ğ•¡][t] = EasyEcon.Getğ•¡( Pt[:ğ•“][t], Ï€Mf, Dst[:w][t,:], Dst[:Lab][t,1:env.Sr], Ps[:N][t,1:env.S], env.Sr )

            # SubSection 4: household lifetime optimization problem å®¶åº­éƒ¨é—¨ç”Ÿå‘½æœŸæ•ˆç”¨æœ€å¤§åŒ–é—®é¢˜
                # 1. prepare sliced data å‡†å¤‡è¾“å…¥æ•°æ®åˆ‡ç‰‡
                local tmpOriginData = DatSlice4Household(t, Dt,Dst,Pt,Ps,Pc,env,
                    S = env.S, Sr = env.Sr, a1 = 0.0, Î¦1 = 0.0, SearchType = "SteadyState"  )
                # 2. solve the optimization, get paths (wealth/capital, asset, UEBMI-indi, consumption, leisure) æ±‚è§£ï¼Œå¾—åˆ°è·¯å¾„ï¼ˆè´¢å¯Œã€èµ„äº§ã€ä¸ªäººåŒ»ä¿ã€æ¶ˆè´¹ã€é—²æš‡ï¼‰
                local tmpRet = House.HHSolve( tmpOriginData, ReturnData = true )
                # 2.5 extract asset (a_{s}) & UEBMI-indi (Î¦_{s}) æå–ä¸ªäººèµ„äº§å’ŒUEBMIä¸ªäººè´¦æˆ·
                House.ExtractAPhi!( tmpRet, tmpOriginData, a1 = 0.0 )
                # 3. distribute results å­˜å‚¨ç»“æœ
                # NOTE: k,a,Î¦ (len=S+1) have an extra element: bequest, so, drop it
                Dst[:ğ’œ][t, 1:env.S] = tmpRet[:ks][1:env.S]
                Dst[:a][t, 1:env.S] = tmpRet[:as][1:env.S]
                Dst[:Î¦][t, 1:env.S] = tmpRet[:Î¦s][1:env.S]
                # NOTE: c,M,MA,MB (len=S)
                Dst[:c][t, 1:env.S] = tmpRet[:cs][1:env.S]
                Dst[:Lab][t, 1:env.Sr] = tmpRet[:ls][1:env.Sr]  # labor supply (not leisure!)
                Dst[:m][t, 1:env.S] .= tmpRet[:Ms][1:env.S]   # medical expenditure
                Dst[:MA][t, 1:env.S] .= tmpRet[:MAs][1:env.S] # outpatient expenditure
                Dst[:MB][t, 1:env.S] .= tmpRet[:MBs][1:env.S] # inpatient expenditure
                Dst[:Î¦Gaps][t, 1:env.S] .= tmpRet[:Î¦Gaps][1:env.S] # inpatient expenditure

            # SubSection 5: fiscal & UE-BMI è´¢æ”¿ &ã€€UE-BMI
                # 1. tax revenues ç¨æ”¶
                Dt[:TRc][t] = Pc[:Î¼] * sum( Dst[:c][t, 1:env.S]   .* Ps[:N][t,1:env.S] )  # consumption tax æ¶ˆè´¹ç¨
                Dt[:TRw][t] = Pc[:Ïƒ] * sum( Dst[:Lab][t, 1:env.Sr] .* Ps[:N][t,1:env.Sr] .* Dst[:w][t, 1:env.Sr] )  # wage tax å·¥èµ„ç¨
                # 2. the gaps of the social pooling account of UE-BMI (positive for gap, negative for surplus)
                Dt[:LI][t] = sum( ( 1 .- Pt[:cpB][t] ) .* Dst[:MB][t, 1:env.S] .* Ps[:N][t,1:env.S] )
                Dt[:LI][t] -= ( 1 .- Pt[:ğ•’][t] .- Pt[:ğ•“][t] ) .* Pt[:Î¶][t] ./ ( 1 .+ Pt[:Î·][t] + Pt[:Î¶][t] ) .* sum( Ps[:N][t,1:env.Sr] .* Dst[:w][t, 1:env.Sr] .* Dst[:Lab][t, 1:env.Sr] )

            # SubSection 6: update aggregated labor supply æ›´æ–°åŠ³åŠ¨åŠ›ä¾›åº”
                tmpL2 = sum( Ps[:N][t,1:env.Sr] .* Dst[:Lab][t, 1:env.Sr] )
            # SubSection 7: update GDP with the updated labor supply (through production function) ä½¿ç”¨æ›´æ–°çš„åŠ³åŠ¨è¦ç´ æ›´æ–°GDPä¼°è®¡
                Dt[:Y][t] = EasyEcon.CDProdFunc( Pt[:A][t], tmpK1, tmpL2, Pt[:Î²][t], Îº = Pc[:Îº], GetPrice = true, TechType = "Hicks"  )[1]

            # SubSection 8: update updating aggregated capital (K)
                # NOTE: there are two ways to update K: one uses the capital market clearing condition (Method A);
                # and the other one uses the capital growth dynamics (Method B); the two methods are equivalent; and I use Method A here.
                # 1. get aggregated investment (I) through capita dynamics é€šè¿‡èµ„æœ¬åŠ¨æ€æ¡ä»¶å¾—åˆ°æŠ•èµ„
                Dt[:I][t] = tmpK1 * Pc[:Îº]
                # 2. aggregate consumption æ±‡æ€»ç¤¾ä¼šæ€»æ¶ˆè´¹
                Dt[:C][t] = sum( Dst[:c][t, 1:env.S] .* Ps[:N][t,1:env.S] )
                # 3. get government purchase (G) through the good market clearing condition é€šè¿‡å•†å“å¸‚åœºå‡ºæ¸…å¾—åˆ°æ”¿åºœè´­ä¹°
                Dt[:G][t] = Dt[:Y][t] - Dt[:I][t] - Dt[:C][t]
                # 4. get government outstanding debt through the fiscal budget é€šè¿‡æ”¿åºœé¢„ç®—çº¦æŸå¾—åˆ°æ”¿åºœå€ºåŠ¡ä½™é¢
                Dt[:D][t] = ( Dt[:G][t] + Dt[:LI][t] - Dt[:TRc][t] - Dt[:TRw][t] ) / (1 - Dt[:r][t])
                # 5. the upper bound of government outstanding debt æ”¿åºœæœªå¿å€ºåŠ¡è½¯çº¦æŸ
                Dt[:D][t] = max( 0.0, min( Dt[:D][t], Dt[:Y][t] * Pt[:D2Ycap][t] ) )
                # 6. record the ratio of government outstanding debt on GDP è®°å½•æœªå¿å€ºåŠ¡ä¸GDPçš„æ¯”
                Dt[:D2Y][t] = Dt[:D][t] / Dt[:Y][t]
                # 7. aggregate/update capital æ±‡æ€»/æ›´æ–°ï¼ˆå¹´åˆï¼‰èµ„æœ¬å­˜é‡
                tmpK2 = sum( Dst[:ğ’œ][t, 1:env.S] .* Ps[:N][t,1:env.S] )

            # Convergence check & go to the next loop æ”¶æ•›æ£€æŸ¥
                # 1. compute errors, using a minor number to avoid exact zeros
                local Err = ( K = abs(tmpK2 / (tmpK1 + eps()) - 1 ), L = abs(tmpL2 / (tmpL1 + eps()) - 1 ) )
                # 2. record original K, L
                local OriGuess = [tmpK1, tmpL1]
                # 3. check
                if (Err.K < atol) & (Err.L < atol)  # converged
                    # 1. save the converged K, L; using mean values
                    Dt[:K][t] = ( tmpK1 + tmpK2 ) / 2; Dt[:L][t] = ( tmpL1 + tmpL2 ) / 2;
                    # 2. print final summary (if not silently solved)
                    if PrintMode != "silent"
                        println("\n\t+ Status: Converged")  # status
                        println("\t+ Round: ", idx)
                        println("\t+ Relative Errors: ",Err)  # print error first
                        println("\t+ Updating of Kap: ",round.([ OriGuess[1], tmpK2, Dt[:K][t] ],digits=6) ) # then print the updating process of K,L
                        println("\t+ Updating of Lab: ",round.([ OriGuess[2], tmpL2, Dt[:L][t] ],digits=6) )
                        println("\t+ NOTE: guess -> re-aggregated -> updated")
                        SummaryYear( t, Dt, Dst, Pt, Ps, env.S, env.Sr )  # print the details of the steady state
                    end
                    break  # ends iteration
                elseif idx == MaxIter  # diverged or too few maxmimum rounds set
                    Dt[:K][t] = ( tmpK1 + tmpK2 ) / 2; Dt[:L][t] = ( tmpL1 + tmpL2 ) / 2;
                    if PrintMode != "silent"
                        println("\n\t+ Status: Maximum iteration reached, not converged")
                        println("\t+ Round: ", idx)
                        println("\t+ Relative Errors: ",Err)
                        println("\t+ Updating of Kap: ",round.([ OriGuess[1], tmpK2, Dt[:K][t] ],digits=6) ) # then print the updating process of K,L
                        println("\t+ Updating of Lab: ",round.([ OriGuess[2], tmpL2, Dt[:L][t] ],digits=6) )
                        println("\t+ NOTE: guess -> re-aggregated -> updated")
                        SummaryYear( t, Dt, Dst, Pt, Ps, env.S, env.Sr )
                    end
                    break  # ends iteration
                else  # go to the next loop
                    # 1. check if the updated labor supply touches the bottom of zero
                    (tmpL2 <     0 || ~isreal(tmpL2))    &&    begin @warn("Labor lower than 0 or complex!"); tmpL2 = 0.01; end
                    # 2. update labor supply
                    tmpL1 += StepLen * (tmpL2 - tmpL1)
                    # 3. use the magic number to set the bottom of capital, which bounds the interest rate in a reasonable range
                    local tmpKfloor = MagicNum * tmpL1
                    # 4. check & update capital supply
                    (tmpK2 < tmpKfloor || ~isreal(tmpK2))    &&    begin @warn("Capital lower than the lower bound or complex!"); tmpK2 = tmpKfloor; end
                    tmpK1 += StepLen * (tmpK2 - tmpK1)
                    # 5. print information, according to :PrintMode
                    if PrintMode in ["full", "concise"]
                        println("\n\t+ Round: ", idx)
                        println("\t+ Relative Errors: ", Err)
                        println("\t+ Updating of Kap: ",round.([ OriGuess[1], tmpK2, Dt[:K][t] ],digits=6) ) # then print the updating process of K,L
                        println("\t+ Updating of Lab: ",round.([ OriGuess[2], tmpL2, Dt[:L][t] ],digits=6) )
                        println("\t+ NOTE: guess -> re-aggregated -> updated")
                    end
                    if PrintMode == "full"
                        SummaryYear( t, Dt, Dst, Pt, Ps, env.S, env.Sr )
                    end
                    # 6. explicitly write continue (as a reminder without practical jobs)
                    continue
                end  # check ends

        end # Gauss-Seidel Iteration ends
        # nomial return
        return nothing
    end  # function ends

    # -----------------------------------------





# ==============================================================================
## SECTION 2: Transition Search è½¬è½¨è·¯å¾„æœç´¢
# NOTE: in this section, we define an in-place function Transition!()
#       æœ¬èŠ‚æˆ‘ä»¬å®šä¹‰ä¸€ä¸ªç›´æ¥ä½œç”¨äºæ•°æ®åŒ…ä¸Šçš„å‡½æ•°Transition!()
#       it is used to search a transition path on input datasets
#       using Gauss-Seidel iterations
#       returns nothing
# ------------
    """
        Transition!( Dt::Dict, Dst::Dict, Pt::Dict, Ps::Dict, Pc::Dict, env::NamedTuple ; atol::Float64 = 1E-8, MaxIter::Int = 100, PrintMode::String = "full", MagicNum::Real = 2.0, StepLen::Real = 0.5 )

    Searches a transition path based on the input datasets;
    requires Initial & Final Steady States searched;
    returns nothing;

    And, the definitions of input parameters are the same as those of SteadyState!()
    """
    function Transition!( Dt::Dict, Dst::Dict, Pt::Dict, Ps::Dict, Pc::Dict, env::NamedTuple ;
        atol::Float64 = 1E-8,  # tolerance of Gauss-Seidel iteration
        MaxIter::Int = 100,  # maximum loops
        PrintMode::String = "full",  # mode of printing, one of ["full","concise","final","silent"]
        MagicNum::Real = 2.0,  # magic number, the lower bound of K/L (capital per labor)
        StepLen::Real = 0.5, # relative step length to update guesses, in range (0,1]
        ReturnLog::Bool = false ) # whether to return a Dict of convergence (errors per loop)
        # ------------
        ## Section: validation
            @assert( PrintMode in ["full","concise","final","silent"] , "undefined PrintMode string" )
            @assert( 0.0 < StepLen <= 1.0 , "invalid StepLen, it should be in range (0,1]" )
            @assert( MagicNum > 0.0 , "invalid MagicNum (capital per capita) which must be greater than 0" )
            Ps[:F][:,env.S] .= 0.0  # forcely refresh mortality in the very last year å¼ºåˆ¶åˆ·æ–°æœ€åä¸€å²çš„æ­»äº¡ç‡ä¸º0
        ## Section: malloc å†…å­˜é¢„åˆ†é…
            # a. linearly fill capital & labor çº¿æ€§å¡«å……èµ„æœ¬å’ŒåŠ³åŠ¨ä¾›åº”
            local tmpK1::Vector{Float64} = LinRange( Dt[:K][1], Dt[:K][env.T], env.T )
            local tmpK2::Vector{Float64} = LinRange( Dt[:K][1], Dt[:K][env.T], env.T )
            local tmpL1::Vector{Float64} = LinRange( Dt[:L][1], Dt[:L][env.T], env.T )
            local tmpL2::Vector{Float64} = LinRange( Dt[:L][1], Dt[:L][env.T], env.T )
            # b. initialization, evenly fill every year's labor among generations å¹³å‡å¡«å……æ¯å¹´æ¯å²äººçš„åŠ³åŠ¨åŠ›ä¾›åº”
            for t in 2:env.T-1
                Dst[:Lab][t,1:env.Sr] .= tmpL1[t] ./ env.Sr
            end
            # c. other convenient variables å…¶ä»–å¿«æ·å˜é‡
            local tmpVal = 1.0    .+  Pt[:z] .* Pt[:Î·]  .+ Pt[:Î¶]
            local Ï€Coef  = Pt[:z] .* (Pt[:Î¸] .+ Pt[:Î·]) ./ tmpVal
            local Ï€Mf    = Pt[:Î¶] ./  tmpVal
            local Ï€Mp    = Pt[:Ï•] ./  tmpVal
            local Ï€M     = Ï€Mf    .+  Ï€Mp
            # d. convenient index å¿«æ·ç´¢å¼•
            local idxS  = 1:env.S
            local idxWorking = 1:env.Sr
            local idxRetired = env.Sr+1:env.S
            local idx2toT = 2:env.T
            local idx1toT = 1:env.T
            local idx2toTminus1 = 2:env.T-1
            local idx1toTminus1 = 1:env.T-1

            # e. save a copy of k_{s}, a_{s}, Î¦_{s} for both init & final steady states
            # NOTE: because we may over-write them, if we want better readiability of the code
            local copy_InitSSk = ( k = Dst[:ğ’œ][1,:],     a = Dst[:a][1,:],     Î¦ = Dst[:Î¦][1,:] )
            local copy_FinaSSk = ( k = Dst[:ğ’œ][env.T,:], a = Dst[:a][env.T,:], Î¦ = Dst[:Î¦][env.T,:] )
            # f. logs of performance/convergence è¿­ä»£æ—¥å¿—
            local PerfLog = Dict( :K => Array{Float64,1}(), :L => Array{Float64,1}() )


        ## Section: Gauss-Seidel Iterations æœç´¢
        for idxiter in 1:MaxIter
            # check: NaN of Capital & Labor èµ„æœ¬å’ŒåŠ³åŠ¨çš„NaNå€¼æ£€æŸ¥ï¼ˆå¿…è¦ï¼Œé˜²æ­¢å¯èƒ½çš„æ•°å€¼é”™è¯¯åä»ç»§ç»­ç‹‚é£™ï¼‰
            @assert( !any(isnan.(tmpK1)) , "NaN found in agg capital" )
            @assert( !any(isnan.(tmpL1)) , "NaN found in agg labor" )

            # Section: Firm Department & PAYG Pension å‚å•†éƒ¨é—¨ä¸å…»è€é‡‘
            for t in idx1toTminus1
                # 1. GDP, r, avg w GDPï¼Œåˆ©ç‡ï¼Œå¹³å‡å·¥èµ„
                Dt[:Y][t], Dt[:r][t], Dt[:wÌ„][t] =
                    EasyEcon.CDProdFunc( Pt[:A][t], tmpK1[t], tmpL1[t], Pt[:Î²][t],
                    Îº = Pc[:Îº], GetPrice = true, TechType = "Hicks"  )
                # 2. wage profile å·¥èµ„æ›²çº¿
                Dst[:w][t,idxWorking], Dt[:o][t] =
                    EasyEcon.WageProfile( Dt[:wÌ„][t], Ps[:Îµ][idxWorking],
                    Ps[:N][t,idxWorking], Dst[:Lab][t,idxWorking], GetScalingCoef = true  )
                # 3. the benefits of PAYG pension å…»è€é‡‘ç»™ä»˜
                Dt[:Î›][t] = EasyEcon.PAYGPension( Ï€Coef[t], # NOTE: diff
                    Dst[:w][t,idxWorking], Ps[:N][t,idxS], Dst[:Lab][t,idxWorking], env.Sr )
                # 4. average transfer amount from firm medical contribution to retired generations å½“æœŸä¼ä¸šåŒ»ä¿ç¼´çº³å¯¹é€€ä¼‘äººå‘˜çš„å¹³å‡è¡¥è´´é‡
                Dt[:ğ•¡][t] = EasyEcon.Getğ•¡( Pt[:ğ•“][t], Ï€Mf[t],  # NOTE: diff
                    Dst[:w][t,idxWorking], Dst[:Lab][t,idxWorking], Ps[:N][t,idxS], env.Sr )
            end # firm & pension ends

            # Section: Household Department & Health Expenditure å®¶åº­éƒ¨é—¨ä¸åŒ»ç–—æ”¯å‡º
            # NOTE: there are three cases to compute in this section:
            #       æœ¬èŠ‚è®¡ç®—ä¸‰ç§æƒ…å½¢ï¼š
            #       1. for those alive in t=1, still working, but change their paths in t>2,...
            #       2. for those alive in t=1, have retired, but change their paths in t>2,...
            #       3. for those born in t=1,...,T (i.e. on the transition path)
            for s in 2:env.Sr
            # NOTE: CASE 1: alive in t=1, working
                # 1. prepare data
                # NOTE: t = 1 (mark year); S = S-s+1 (left years to live); Sr = Sr-s+1 (left years to work)
                #       remember, when s=Sr, we are standing at the beginning of the year of age Sr
                local YearsToLive::Int = env.S  - s + 1
                local YearsToWork::Int = env.Sr - s + 1
                local tmpOriginData = DatSlice4Household(1, Dt,Dst,Pt,Ps,Pc,env, S = YearsToLive, Sr = YearsToWork,
                    a1 = Dst[:a][1,s], Î¦1 = Dst[:Î¦][1,s], SearchType = "AliveInYear0Working"  )
                # 2. optimization
                local tmpRet = House.HHSolve( tmpOriginData, ReturnData = true )
                # 3. extract asset (a_{s}) & UEBMI-indi (Î¦_{s})
                House.ExtractAPhi!( tmpRet, tmpOriginData, a1 = Dst[:a][1,s] )
                # 4. distribute results
                # NOTE: k,a,Î¦ (len=S+1) have an extra element: bequest, so, drop it
                diagw!( Dst[:ğ’œ], tmpRet[:ks][1:YearsToLive], offset = s - 1 )
                diagw!( Dst[:a], tmpRet[:as][1:YearsToLive], offset = s - 1 )
                diagw!( Dst[:Î¦], tmpRet[:Î¦s][1:YearsToLive], offset = s - 1 )
                # NOTE: c,M,MA,MB (len=S)
                diagw!( Dst[:c], tmpRet[:cs][1:YearsToLive], offset = s - 1 )
                diagw!( Dst[:Lab], tmpRet[:ls][1:YearsToWork], offset = s - 1 )
                diagw!( Dst[:m], tmpRet[:Ms][1:YearsToLive], offset = s - 1 )
                diagw!( Dst[:MA], tmpRet[:MAs][1:YearsToLive], offset = s - 1 )
                diagw!( Dst[:MB], tmpRet[:MBs][1:YearsToLive], offset = s - 1 )
                diagw!( Dst[:Î¦Gaps], tmpRet[:Î¦Gaps][1:YearsToLive], offset = s - 1 )
            end
            for s in env.Sr+1:env.S
            # NOTE: CASE 2: alive in t=1, retired
                # 1. prepare data
                # NOTE: t = 1 (mark year); S = S-s+1 (left years to live)
                local YearsToLive::Int = env.S  - s + 1
                local tmpOriginData = DatSlice4Household(1, Dt,Dst,Pt,Ps,Pc,env, S = YearsToLive, Sr = 0,
                    a1 = Dst[:a][1,s], Î¦1 = Dst[:Î¦][1,s], SearchType = "AliveInYear0Retired"  )
                # 2. optimization
                local tmpRet = House.HHSolve_Retired( tmpOriginData, ReturnData = true )
                # 3. extract asset (a_{s}) & UEBMI-indi (Î¦_{s})
                House.ExtractAPhi_Retired!( tmpRet, tmpOriginData, a1 = Dst[:a][1,s] )
                # 4. distribute results
                # NOTE: k,a,Î¦ (len=S+1) have an extra element: bequest, so, drop it
                diagw!( Dst[:ğ’œ], tmpRet[:ks][1:YearsToLive], offset = s - 1 )
                diagw!( Dst[:a], tmpRet[:as][1:YearsToLive], offset = s - 1 )
                diagw!( Dst[:Î¦], tmpRet[:Î¦s][1:YearsToLive], offset = s - 1 )
                # NOTE: c,M,MA,MB (len=S)
                diagw!( Dst[:c], tmpRet[:cs][1:YearsToLive], offset = s - 1 )
                diagw!( Dst[:m], tmpRet[:Ms][1:YearsToLive], offset = s - 1 )
                diagw!( Dst[:MA], tmpRet[:MAs][1:YearsToLive], offset = s - 1 )
                diagw!( Dst[:MB], tmpRet[:MBs][1:YearsToLive], offset = s - 1 )
                diagw!( Dst[:Î¦Gaps], tmpRet[:Î¦Gaps][1:YearsToLive], offset = s - 1 )
            end
            # NOTE: refresh the capital/asset/UEBMI-indi in our initial steady state
                Dst[:ğ’œ][1,idxS] = copy_InitSSk.k
                Dst[:a][1,idxS] = copy_InitSSk.a
                Dst[:Î¦][1,idxS] = copy_InitSSk.Î¦
            for t in 1:env.T-1
            # NOTE: CASE 3: born on transition path
                # 1. prepare data
                # NOTE: S = S, Sr = Sr, t = t
                #       everyone has a complete life-cycle
                local tmpOriginData = DatSlice4Household(t, Dt,Dst,Pt,Ps,Pc,env, S = env.S, Sr = env.Sr,
                    a1 = 0.0, Î¦1 = 0.0, SearchType = "BornInTransition"  )
                # 2. optimization
                local tmpRet = House.HHSolve( tmpOriginData, ReturnData = true )
                # 3. extract asset (a_{s}) & UEBMI-indi (Î¦_{s})
                House.ExtractAPhi!( tmpRet, tmpOriginData, a1 = 0.0 )
                # 4. distribute results
                # NOTE: k,a,Î¦ (len=S+1) have an extra element: bequest, so, drop it
                diagw!( Dst[:ğ’œ], tmpRet[:ks][idxS], offset = 1 - t )
                diagw!( Dst[:a], tmpRet[:as][idxS], offset = 1 - t )
                diagw!( Dst[:Î¦], tmpRet[:Î¦s][idxS], offset = 1 - t )
                # NOTE: c,M,MA,MB (len=S)
                diagw!( Dst[:c], tmpRet[:cs][idxS], offset = 1 - t )
                diagw!( Dst[:Lab], tmpRet[:ls][idxWorking], offset = 1 - t )
                diagw!( Dst[:m], tmpRet[:Ms][idxS], offset = 1 - t )
                diagw!( Dst[:MA], tmpRet[:MAs][idxS], offset = 1 - t )
                diagw!( Dst[:MB], tmpRet[:MBs][idxS], offset = 1 - t )
                diagw!( Dst[:Î¦Gaps], tmpRet[:Î¦Gaps][idxS], offset = 1 - t )
            end
            # NOTE: refresh the capital/asset/UEBMI-indi in our final steady state
                Dst[:ğ’œ][env.T,idxS] = copy_FinaSSk.k
                Dst[:a][env.T,idxS] = copy_FinaSSk.a
                Dst[:Î¦][env.T,idxS] = copy_FinaSSk.Î¦


            # Section: Fiscal, Consumption & Labor Aggregation è´¢æ”¿ï¼Œæ¶ˆè´¹ä¸åŠ³åŠ¨åŠ›å¸‚åœº
            for t in idx1toTminus1
                # 1. aggregated consumption æ€»æ¶ˆè´¹
                Dt[:C][t] = sum( Dst[:c][t,idxS] .* Ps[:N][t,idxS] )
                # 2. tax revenues è´¢æ”¿æ”¶å…¥
                Dt[:TRc][t] = Pc[:Î¼] * Dt[:C][t]
                Dt[:TRw][t] = Pc[:Ïƒ] * sum( Dst[:Lab][t, idxWorking] .* Ps[:N][t,idxWorking] .* Dst[:w][t, idxWorking] )
                # 3. the gaps of the social pooling account of UE-BMI (positive for gap, negative for surplus)
                Dt[:LI][t] = sum( ( 1 .- Pt[:cpB][t] ) .* Dst[:MB][t, idxS] .* Ps[:N][t,idxS] )
                Dt[:LI][t] -= ( 1 .- Pt[:ğ•’][t] .- Pt[:ğ•“][t] ) .* Pt[:Î¶][t] ./
                    ( 1 .+ Pt[:Î·][t] + Pt[:Î¶][t] ) .*
                    sum( Ps[:N][t,idxWorking] .* Dst[:w][t,idxWorking] .* Dst[:Lab][t,idxWorking] )
                # 4. update aggregated labor supply æ›´æ–°åŠ³åŠ¨åŠ›ä¾›åº”
                tmpL2[t] = sum( Ps[:N][t,idxWorking] .* Dst[:Lab][t,idxWorking] )
                # 5. update GDP using new L æ›´æ–°GDP
                Dt[:Y][t] = EasyEcon.CDProdFunc( Pt[:A][t], tmpK1[t], tmpL2[t], Pt[:Î²][t], Îº = Pc[:Îº], GetPrice = true, TechType = "Hicks"  )[1]
            end # fiscal, consumption & labor-agg end

            # Section: Government debt æ”¿åºœå€ºåŠ¡
            # NOTE: in this paper, D is always zero (self-supported fiscal budget)
            for t in idx1toTminus1
                # 1. government outstanding debt, through the capital market æ”¿åºœè´Ÿå€ºï¼Œé€šè¿‡èµ„æœ¬å¸‚åœºå‡è¡¡
                Dt[:D][t] = tmpK1[t] - sum( Ps[:N][t,idxS] .* ( Dst[:a][t,idxS] .+ Dst[:Î¦][t,idxS] ) )
                Dt[:D][t] = max( 0.0, min( Dt[:D][t], Dt[:Y][t] * Pt[:D2Ycap][t] ) )
                Dt[:D2Y][t] = Dt[:D][t] / Dt[:Y][t]
            end # government

            # Section: Government purchase, Investment & Capital æ”¿åºœè´­ä¹°ï¼ŒæŠ•èµ„ä¸èµ„æœ¬å¸‚åœº
            # NOTE: because we use D_{t+1} to compute G_{t} (well ... though doesnot matter in this paper but for generality)
            #       we seperate D_{t} from other variables, in a single loop
            for t in idx1toTminus1
                # 1. government purchase æ”¿åºœè´­ä¹°
                Dt[:G][t] = Dt[:TRw][t] + Dt[:TRc][t] + Dt[:D][t+1] -
                            Dt[:LI][t] - Dt[:r][t] * Dt[:D][t]
                # 2. investment æŠ•èµ„
                Dt[:I][t] = Dt[:Y][t] - Dt[:G][t] - Dt[:C][t]

            end # gov-purchase, investment & capital-agg end

            # Section: Reaggregate Capital æ±‡æ€»èµ„æœ¬
            # NOTE: notice the index of looping! :)
            # NOTE: re-aggregate capital through the dynamics of capital growth
            for t in env.T-1:-1:2
                tmpK2[t]  = tmpK1[t+1] - Dt[:I][t]
                tmpK2[t] /= 1.0 - Pc[:Îº]
            end


            # Convergence check & go to the next loop æ”¶æ•›æ£€æŸ¥
            # 1. compute errors, using a minor number to avoid exact zeros
            # NOTE: we care the maximum of the errors of a complete path æˆ‘ä»¬å…³å¿ƒæ•´æ¡åºåˆ—è¯¯å·®çš„æœ€å¤§å€¼
            local Err = ( K = findmax( abs.(tmpK2 ./ tmpK1 .- 1.0 )[idx2toTminus1] )[1],
                          L = findmax( abs.(tmpL2 ./ tmpL1 .- 1.0 )[idx2toTminus1] )[1]   )
            # performance log è®°å½•è¯¯å·®
                append!(PerfLog[:K], Err.K)
                append!(PerfLog[:L], Err.L)
            # 2. check
            if ( Err.K < atol ) & (Err.L < atol)  # converged
                # 1. save the converged K,L, using mean values
                Dt[:K][idx2toTminus1] = ( tmpK1 .+ tmpK2 )[idx2toTminus1] ./ 2
                Dt[:L][idx2toTminus1] = ( tmpL1 .+ tmpL2 )[idx2toTminus1] ./ 2
                # 2. print final summary (if not silently solved)
                if PrintMode != "silent"
                    println("\n\t+ Status: Converged")  # status
                    println("\t+ Round: ", idxiter)
                    println("\t+ Max Relative Errors: ",Err)  # print error first
                    # SummaryYear( t, Dt, Dst, Pt, Ps, env.S, env.Sr )  # print the details of the steady state
                end
                break  # ends iteration
            elseif idxiter == MaxIter # diverged or too few maximum rounds of loops
                # 1. save the converged K,L, using mean values
                Dt[:K][idx2toTminus1] = ( tmpK1 .+ tmpK2 )[idx2toTminus1] ./ 2
                Dt[:L][idx2toTminus1] = ( tmpL1 .+ tmpL2 )[idx2toTminus1] ./ 2
                # 2. print final summary (if not silently solved)
                if PrintMode != "silent"
                    println("\n\t+ Status: Maximum iteration reached, not converged")
                    println("\t+ Round: ", idxiter)
                    println("\t+ Max Relative Errors: ",Err)  # print error first
                    # SummaryYear( t, Dt, Dst, Pt, Ps, env.S, env.Sr )  # print the details of the steady state
                end
                break  # ends iteration

            else  # go to the next loop
                # 1. check if the updated labor supply touches the bottom of zero
                local chkidx = (tmpL2 .< 0.0) .| (tmpL2 .!= real.(tmpL2))
                tmpL2[chkidx] .= 0.001
                # 2. update labor supply
                tmpL1[idx2toTminus1] .+= StepLen .* ( tmpL2 .- tmpL1 )[idx2toTminus1]
                # 3. use the magic number to set the bottom of capital, which bounds the interest rate in a reasonable range
                local tmpKfloor = MagicNum .* findmin(tmpL1)[1]
                println( findmin(tmpK1 .- tmpK2)[1] )
                # 4. check & update capital supply
                chkidx = (tmpK2 .< tmpKfloor) .| (tmpK2 .!= real.(tmpK2))
                tmpK2[chkidx] .= tmpKfloor
                tmpK1[idx2toTminus1] .+= StepLen .* ( tmpK2 .- tmpK1 )[idx2toTminus1]
                # 5. print information, according to :PrintMode
                if PrintMode in ["full", "concise"]
                    println("\n\t+ Round: ", idxiter)
                    println("\t+ Max Relative Errors: ", Err)
                    # println("\t+ Updating of Kap: ",round.([ OriGuess[1], tmpK2, Dt[:K][t] ],digits=6) ) # then print the updating process of K,L
                    # println("\t+ Updating of Lab: ",round.([ OriGuess[2], tmpL2, Dt[:L][t] ],digits=6) )
                    # println("\t+ NOTE: guess -> re-aggregated -> updated")
                end
                # if PrintMode == "full"
                #     # SummaryYear( t, Dt, Dst, Pt, Ps, env.S, env.Sr )
                # end
                # 6. explicitly write continue (as a reminder without practical jobs)
                continue

            end  # branch ends

        end  # Gauss-Seidel ends
        # nominal returns
        if ReturnLog
            return PerfLog::Dict
        else
            return nothing
        end
    end

































































# ==============================================================================
end  # module ends
#
