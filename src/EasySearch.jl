__precompile__()
"""
    EasySearch

searching steady states & transition path;
concise design;
requires modules/packages in LOAD_PATH
"""
module EasySearch
    import EasyHousehold  # household lifetime optimization
    import EasyEcon  # economic functions
    import EasyMath: vecExpand, diagr  # for DatSlice4Household(), to handle cases that touch final steady state in last years of transition path ç”¨äºå¤„ç†DatSlice4Household()å‡½æ•°ä¸­å¯¹äºå¤„äºè½¬è½¨è·¯å¾„ä¸Šæœ€åå‡ å¹´å‡ºç”Ÿçš„äººæœ‰ä¸€æ®µç”Ÿå‘½è½åœ¨äº†æœ€ç»ˆç¨³æ€é‡Œçš„æƒ…å½¢ï¼Œç”¨äºä¸ºä»–ä»¬åŠ é•¿è¡¥å…¨è·¯å¾„


    # ==========================================================================
    """
        DatSlice4Household( t::Int, Dt::Dict, Dst::Dict, Pt::Dict, Ps::Dict, S::Int, Sr::Int ; IsSteadyState::Bool = true )

    Slices data, generates a Dict **d** for LifeDecision() in EasyHousehold module (just input **Pc** to LifeDecision());
    based on data collections generated by proc_InitPars.jl & proc_VarsDeclare.jl;
    the parameter **IsSS** controls if the slice is for a steady state (if true, use cross-sectional values to fill vectors, if false, use data from year **t** to **t+S**)
    automatically handle the case that there are several years toching possible final steady state;
    returns a Dict **d**.

    ç”¨äºä¸ºç¨³æ€ã€è½¬è½¨è·¯å¾„çš„å®¶æˆ·æœ€ä¼˜å†³ç­–é—®é¢˜åˆ‡ç‰‡æ•°æ®ï¼›å·²ç»èƒ½å¤Ÿè‡ªåŠ¨é›†ä¸­å¤„ç†å„ç±»å¼‚å¸¸ï¼ˆå°¤å…¶æ˜¯touchåˆ°æœ€ç»ˆç¨³æ€æ—¶çš„æ•°æ®æ‹“å±•é—®é¢˜ï¼‰

    # Depends on:
    1. EasyMath.vecExpand() : expand vectors for those born in laste years of transition path. some years of these men have reached the final steady state
    2. EasyMath.diagr(): read diagonal elements from a matrix, automatically add/drop extra elements
    """
    function DatSlice4Household( t::Int, Dt::Dict, Dst::Dict, Pt::Dict, Ps::Dict, S::Int, Sr::Int ; IsSteadyState::Bool = true )
        local d = Dict{Symbol,Vector{Float64}}()  # use strong type declaration
        # Case 1: for SteadyState ç¨³æ€
        # NOTE: use one year's data (year t) to fill the whole vectors é’ˆå¯¹ç¨³æ€ï¼Œä½¿ç”¨ç‰¹å®šä¸€å¹´çš„å€¼å¡«å……æ•´æ¡è·¯å¾„
        if IsSteadyState
            # -------- len = S
            d[:r] = fill(Dt[:r][t],S) # interest rates
            d[:cpB] = fill(Pt[:cpB][t],S) # co-payment rate of inpatient expenditure
            d[:q] = fill(Pt[:q][t],S) # m2c ratio
            d[:p] = Ps[:p][1:S] # MA/MB ratio
            d[:F] = Ps[:F][t,1:S] # mortality
            # -------- len = Sr
            d[:Ï•] = fill(Pt[:Ï•][t],Sr) # contribution: agent â†’ UEBMI
            d[:Î¶] = fill(Pt[:Î¶][t],Sr) # contribution: firm â†’ UEBMI
            d[:Î·] = fill(Pt[:Î·][t],Sr) # contribution: firm â†’ pension
            d[:Î¸] = fill(Pt[:Î¸][t],Sr) # contribution: agent â†’ pension
            d[:z] = fill(Pt[:z][t],Sr) # collection rate of pension
            d[:ğ•’] = fill(Pt[:ğ•’][t],Sr) # transfer rate from firm contribution of UEBMI to working agents
            d[:w] = Dst[:w][t,1:Sr] # wage level
            # -------- len = S - Sr
            d[:Î›] = fill(Dt[:Î›][t],S-Sr) # pension benefit amounts
            d[:ğ•¡] = fill(Dt[:ğ•¡][t],S-Sr) # transfer amounts from firm contribution of UEBMI to retired generations
        else
        # Case 2: for those born on transition path ä¸ºé‚£äº›åœ¨è½¬è½¨è·¯å¾„ä¸Šå‡ºç”Ÿçš„äºº
        # NOTE: just use "end" keyword to get a uniform grammer for different cases, vecExpand() will delete extra elements if too-long & add extra elements if too-short
        # NOTE: some data in Ps & Dst requires diagonally read; however, pls note we cannot simply repeat the last element (final steady state distribution)
            # -------- len = S
            d[:r] = vecExpand(Dt[:r][t:end], S) # interest rates
            d[:cpB] = vecExpand(Pt[:cpB][t:end], S) # co-payment rate of inpatient expenditure
            d[:q] = vecExpand(Pt[:q][t:end], S) # m2c ratio
            d[:p] = Ps[:p][1:S] # MA/MB ratio
            d[:F] = diagr(Ps[:F], offset = 1 - t , LEN = S) # mortality, automatically handle the case of touching the last row
            # -------- len = Sr
            d[:Ï•] = vecExpand(Pt[:Ï•][t:end], Sr) # contribution: agent â†’ UEBMI
            d[:Î¶] = vecExpand(Pt[:Î¶][t:end], Sr) # contribution: firm â†’ UEBMI
            d[:Î·] = vecExpand(Pt[:Î·][t:end], Sr) # contribution: firm â†’ pension
            d[:Î¸] = vecExpand(Pt[:Î¸][t:end], Sr) # contribution: agent â†’ pension
            d[:z] = vecExpand(Pt[:z][t:end], Sr) # collection rate of pension
            d[:ğ•’] = vecExpand(Pt[:ğ•’][t:end], Sr) # transfer rate from firm contribution of UEBMI to working agents
            d[:w] = diagr(Dst[:w], offset = 1 - t, LEN = Sr) # wage level
            # -------- len = S - Sr
            d[:Î›] = vecExpand(Dt[:Î›][t:end], S-Sr) # pension benefit amounts
            d[:ğ•¡] = vecExpand(Dt[:ğ•¡][t:end], S-Sr) # transfer amounts from firm contribution of UEBMI to retired generations
        end
        # return
        return d::Dict
    end

    # -------------------------------------------------
    """
        SteadyState!( t::Int, Guess::NamedTuple, Dt::Dict, Dst::Dict, env::NamedTuple, Pt::Dict, Ps::Dict, Pc::Dict ; atol::Float64 = 1E-8, MaxIter::Int = 100, PrintMode::String = "full", MagicNum::Real = 2.0, StepLen::Real = 0.5 )

    Searches steady state on a specific **t** slice, using guesses of interest rate & labor (**Guess**);
    the results will be directly/in-place written in data collections (**Dt**, **Dst**);
    returns nothing.

    ## Inputs:
    1. t : the year to search steady state on, it should be less than or equal to *env.MAX_YEAR*
    2. Guess : a NamedTuple consisting of two elements: ( r = interest rate in digits, L = labor factor )
    3. Dt : a data collection to modify/write, containing year data; defined in proc_VarsDeclare
    4. Dst : a data collection to modify/write, containing age Ã— year data; defined in proc_VarsDeclare
    5. env : a parameter collection containing basic parameters like MAX_AGE, RETIRE_AGE and others
    6. Pt : a parameter collection containing year data, won't be modified
    7. Ps : a parameter collection containing age specific data & demographic data (population & mortality); won't be modified
    8. Pc : a parameter collection containing constant data, won't be modified
    9. atol : tolerance of Gauss-Seidel iteration
    10. MaxIter : maximum loops
    11. PrintMode : a string to decide how to display results & loop information
        1. "full" : print all information, including round, error, summary of economy in each round; print a detailed summary when exit
        2. "concise" : print round, error, but no summary of economy for each round; print a detailed summary when ends
        3. "final": print nothing for each round; print a detailed summary when iteration ends
        4. "silent" : nothing printed for each round; nothing printed when iteration ends
    12. MagicNum : a lower bound of capital per labor (K/L) to prevent divergence out of interest rate (a function of capital per labor)
    13. StepLen : relative step length to update guesses of Gauss-Seidel algorithm, in range (0,1]

    ## Modified:
    1. Dt: update economic variables (e.g. GDP, interest rate)
    2. Dst: update consumption, labor and other age-specific data

    ## Iteration Steps:
    1. Firm department
    2. Pension
    3. Household problems
    4. Fiscal, Aggregation & Update

    ## Depends on:
    1.

    """
    function SteadyState!( t::Int, Guess::NamedTuple, Dt::Dict, Dst::Dict,
        env::NamedTuple, Pt::Dict, Ps::Dict, Pc::Dict ;
        atol::Float64 = 1E-8,  # tolerance of Gauss-Seidel iteration
        MaxIter::Int = 100,  # maximum loops
        PrintMode::String = "full",  # mode of printing
        MagicNum::Real = 2.0,  # magic number, the lower bound of K/L (capital per labor)
        StepLen::Real = 0.5  # relative step length to update guesses, in range (0,1]
    )
        ## Section: validation
        @assert( 0 < t <= env.T , string("t not in range [1, ",env.T,"], received :",t) )
        @assert( isa(Guess.r, Real) & (Guess.L >= 0.0), "please check your Guess::NamedTuple" )  # simutaneously check existence of r, L in Guess and their range
        @assert( PrintMode in ["full","concise","final","silent"] , "undefined PrintMode string" )
        @assert( 0.0 < StepLen <= 1.0 , "invalid StepLen, it should be in range (0,1]" )
        @assert( MagicNum > 0.0 , "invalid MagicNum which must be greater than 0" )
        Ps[:F][t,env.S] = 0.0  # forcely refresh mortality in the very last year å¼ºåˆ¶åˆ·æ–°æœ€åä¸€å²çš„æ­»äº¡ç‡ä¸º0
        ## Section: malloc
        local tmpK1::Float64, tmpK2::Float64  # temporary variables of capital factor in iterations
        local tmpL1::Float64, tmpL2::Float64  # temporary variables of labor factor
        tmpL1 = Guess.L  # initialization
        ## Section: intermediate variables & abbreviations
        local tmpVal::Float64 = 1.0 + Pt[:z][t] * Pt[:Î·][t] + Pt[:Î¶][t] # a temporary variable
        local Ï€Coef::Float64 = Pt[:z][t] * (Pt[:Î¸][t] + Pt[:Î·][t]) / tmpVal # total contribution to pension (on nomial wage level)
        local Ï€Mf::Float64 = Pt[:Î¶][t] / tmpVal # firm contribution rate to UE-BMI
        local Ï€Mp::Float64 = Pt[:Ï•][t] / tmpVal # employee/personal contribution rate to UE-BMI
        local Ï€M = Ï€Mf + Ï€Mp # total contribution rate to UE-BMI on nomial wage level
        ## Section: fill labor with an even distribution to initialize labor ä½¿ç”¨å¹³å¦çš„åŠ³åŠ¨åŠ›åˆ†å¸ƒå¡«å……ä»¥åˆå§‹åŒ–
        Dst[:Lab][t,1:env.Sr] .= tmpL1 / env.Sr

        ## Section: Gauss-Seidel Iterations
        for idx in 1:MaxIter
            # SubSection 0: header information æ‰“å°å¤´éƒ¨ä¿¡æ¯
            PrintMode == "full"  &&   println("\t+ Round: ",idx)
            # SubSection 1: firm department å‚å•†éƒ¨é—¨
                # 1. production function & firm optimal decisions ç”Ÿäº§å‡½æ•° & å‚å•†æœ€ä¼˜å†³ç­–
                if idx == 1   # NOTE: use interest rate & labor to get capital in the first round  ç¬¬ä¸€è½®ä½¿ç”¨åˆ©ç‡å’ŒåŠ³åŠ¨åŠ›åæ¨å‡ºèµ„æœ¬å­˜é‡
                    tmpK1 = tmpL1 * ( (Guess.r + Pc[:Îº]) / (Pt[:Î²][t] * Pt[:A][t]) ) ^ (1.0 / (Pt[:Î²][t] - 1.0))
                    @assert( tmpK1 > 0.0 , string("negative K found in round: ", idx) ) # check capital
                    Dt[:Y][t], tmpVal, Dt[:wÌ„][t] = EasyEcon.CDProdFunc( Pt[:A][t], tmpK1, tmpL1, Pt[:Î²][t], Îº = Pc[:Îº], GetPrice = true, TechType = "Hicks"  ) # optimal decision æœ€ä¼˜å†³ç­–ï¼Œè¿”å›ä»·æ ¼
                else
                    Dt[:Y][t], Dt[:r][t], Dt[:wÌ„][t] = EasyEcon.CDProdFunc( Pt[:A][t], tmpK1, tmpL1, Pt[:Î²][t], Îº = Pc[:Îº], GetPrice = true, TechType = "Hicks"  ) # optimal decision æœ€ä¼˜å†³ç­–ï¼Œè¿”å›ä»·æ ¼
                end
                # 2. wage profiling å·¥èµ„æ›²çº¿
                Dst[:w][t,:], Dt[:o][t] = EasyEcon.WageProfile( Dt[:wÌ„][t], Ps[:Îµ][1:env.Sr], Ps[:N][t,1:env.Sr], Dst[:Lab][t,1:env.Sr], GetScalingCoef = true  )
            # SubSection 2: PAYG pension benefits å…»è€é‡‘ç»™ä»˜
                Dt[:Î›][t] = EasyEcon.PAYGPension( Ï€Coef, Dst[:w][t,:], Ps[:N][t,:], Dst[:Lab][t,:], env.Sr )
            # SubSection 3: average transfer amount from firm medical contribution to retired generations å½“æœŸä¼ä¸šåŒ»ä¿ç¼´çº³å¯¹é€€ä¼‘äººå‘˜çš„å¹³å‡è¡¥è´´é‡
                Dt[:ğ•¡][t] = EasyEcon.Getğ•¡( Pt[:ğ•“][t], Ï€Mf, Dst[:w][t,:], Dst[:Lab][t,1:env.Sr], Ps[:N][t,1:env.S], env.Sr )
            # SubSection 4: household lifetime optimization å®¶åº­éƒ¨é—¨ç”Ÿå‘½æœŸæ•ˆç”¨æœ€å¤§åŒ–é—®é¢˜
                # 1. prepare sliced data å‡†å¤‡è¾“å…¥æ•°æ®åˆ‡ç‰‡
                local tmpd = DatSlice4Household(t, Dt,Dst,Pt,Ps,env.S,env.Sr, IsSteadyState = true)  # is steady state, use cross-sectional data to fill paths
                # 2. solve the optimization, get paths æ±‚è§£ï¼Œå¾—åˆ°è·¯å¾„ï¼ˆè´¢å¯Œã€èµ„äº§ã€ä¸ªäººåŒ»ä¿ã€æ¶ˆè´¹ã€é—²æš‡ï¼‰
                local tmpRet = EasyHousehold.LifeDecision(0.0, 0.0, Pc, tmpd, env.S, env.Sr)
                # 3. distribute results å­˜å‚¨ç»“æœ
                Dst[:ğ’œ][t, 1:env.S] = tmpRet[:ğ’œ] # wealth
                Dst[:a][t, 1:env.S] = tmpRet[:a]  # personal asset
                Dst[:Î¦][t, 1:env.S] = tmpRet[:Î¦]  # individual medical account (UE-BMI)
                Dst[:c][t, 1:env.S] = tmpRet[:c]  # total consumption
                Dst[:Lab][t, 1:env.Sr] .= 1.0 .- tmpRet[:l]  # labor supply (converting leisure to labor)
                # 4. other derived results å…¶ä»–è¡ç”Ÿçš„ç»“æœ
                Dst[:m][t, 1:env.S] .= tmpRet[:c] .* Pt[:q][t]  # total medical expenditure
                Dst[:MA][t, 1:env.S] .= Dst[:m][t, 1:env.S] .* Ps[:p][1:env.S] ./ (1.0 .+ Ps[:p][1:env.S])  # outpatient expenditure
                Dst[:MB][t, 1:env.S] .= Dst[:m][t, 1:env.S] ./ (1.0 .+ Ps[:p][1:env.S])  # inpatient expenditure
            # SubSection 5: fiscal & UE-BMI è´¢æ”¿ &ã€€UE-BMI
                # 1. tax revenues ç¨æ”¶
                Dt[:TRc][t] = Pc[:Î¼] * sum( Dst[:c][t, 1:env.S]   .* Ps[:N][t,1:env.S] )  # consumption tax æ¶ˆè´¹ç¨
                Dt[:TRc][t] = Pc[:Ïƒ] * sum( Dst[:Lab][t, 1:env.Sr] .* Ps[:N][t,1:env.Sr] .* Dst[:w][t, 1:env.Sr] )  # consumption tax æ¶ˆè´¹ç¨






        end # Gauss-Seidel Iterations end



        return nothing
    end

    # -----------------------------------------












# ==============================================================================
end  # module ends
#
