__precompile__()
"""
    EasySearch

searching steady states & transition path;
concise design;
requires modules/packages in LOAD_PATH
"""
module EasySearch
    import EasyHousehold  # household lifetime optimization
    import EasyEcon  # economic functions
    import EasyMath: vecExpand, diagr  # for DatSlice4Household(), to handle cases that touch final steady state in last years of transition path ç”¨äºå¤„ç†DatSlice4Household()å‡½æ•°ä¸­å¯¹äºå¤„äºè½¬è½¨è·¯å¾„ä¸Šæœ€åå‡ å¹´å‡ºç”Ÿçš„äººæœ‰ä¸€æ®µç”Ÿå‘½è½åœ¨äº†æœ€ç»ˆç¨³æ€é‡Œçš„æƒ…å½¢ï¼Œç”¨äºä¸ºä»–ä»¬åŠ é•¿è¡¥å…¨è·¯å¾„


    # ==========================================================================
    """
        SummaryYear( t::Int, Dt::Dict, Dst::Dict, Pt::Dict, Ps::Dict, S::Int, Sr::Int )

    Summarizes a specific cross-sectional; usually used in the summary of steady states;
    It returns nothing but prints to console;
    """
    function SummaryYear( t::Int, Dt::Dict, Dst::Dict, Pt::Dict, Ps::Dict, S::Int, Sr::Int )
        println("\t","."^40, " Factor Markets")
        println("\t+ Aggregated Capital: ", Dt[:K][t] )
        println("\t+ Aggregated Labor  : ", Dt[:L][t] )
        println("\t+ Net Intereste Rate: ", Dt[:r][t] )
        println("\t+ Average Wage Level: ", Dt[:wÌ„][t] )
        println("\t","-"^40, " Good Market")
        println("\t+ GDP               : ", Dt[:Y][t] )
        println("\t+ C, I, G           : ", [ Dt[:C][t], Dt[:I][t], Dt[:G][t] ]  )
        println("\t+ C, I, G Shares    : ", [ Dt[:C][t], Dt[:I][t], Dt[:G][t] ] ./ (Dt[:Y][t] + eps())  )
        println("\t","."^40, " General Fiscal")
        println("\t+ TaxRev Consumption: ", Dt[:TRc][t] )
        println("\t+ TaxRev Wage Income: ", Dt[:TRw][t] )
        println("\t+ Debt & Debt/GDP   : ", [ Dt[:D][t], Dt[:D2Y][t] ] )
        println("\t","."^40, " PAYG Pension")
        println("\t+ Benefit Amount    : ", Dt[:Î›][t] )
        println("\t+ Substitution Rate : ", Dt[:Î›][t] / (Dt[:wÌ„][t] * Dt[:L][t] / sum(Ps[:N][t, 1:Sr]) + eps())  )
        println("\t","."^40, " UE-BMI")
        println("\t+ Gap of Pooling Acc: ", Dt[:LI][t] )
        println("\t+ Gap/GDP           : ", Dt[:LI][t] / (Dt[:Y][t] + eps()) )
        println("\t+ Gap/TaxRev        : ", Dt[:LI][t] / (Dt[:TRc][t] + Dt[:TRw][t] + eps()) )
        println("\t","."^40, " Household Department")
        println("\t+ Agg Wealth : ", sum(Ps[:N][t, 1:S] .* Dst[:ğ’œ][t, 1:S]) )
        println("\t+ Agg Personal Asset: ", sum(Ps[:N][t, 1:S] .* Dst[:a][t, 1:S]) )
        println("\t+ Agg UEBMI Indi-Acc: ", sum(Ps[:N][t, 1:S] .* Dst[:Î¦][t, 1:S]) )
        println("\t+ Max Wealth & Loc  : ", findmax(Dst[:ğ’œ][t, 1:S]) )  # prepared for possible DP, which can help check if DP works well
        println("\t","-"^40)

        return nothing
    end

    # ==========================================================================
    """
        DatSlice4Household( t::Int, Dt::Dict, Dst::Dict, Pt::Dict, Ps::Dict, S::Int, Sr::Int ; IsSteadyState::Bool = true )

    Slices data, generates a Dict **d** for LifeDecision() in EasyHousehold module (just input **Pc** to LifeDecision());
    based on data collections generated by proc_InitPars.jl & proc_VarsDeclare.jl;
    the parameter **IsSS** controls if the slice is for a steady state (if true, use cross-sectional values to fill vectors, if false, use data from year **t** to **t+S**)
    automatically handle the case that there are several years toching possible final steady state;
    returns a Dict **d**.

    ç”¨äºä¸ºç¨³æ€ã€è½¬è½¨è·¯å¾„çš„å®¶æˆ·æœ€ä¼˜å†³ç­–é—®é¢˜åˆ‡ç‰‡æ•°æ®ï¼›å·²ç»èƒ½å¤Ÿè‡ªåŠ¨é›†ä¸­å¤„ç†å„ç±»å¼‚å¸¸ï¼ˆå°¤å…¶æ˜¯touchåˆ°æœ€ç»ˆç¨³æ€æ—¶çš„æ•°æ®æ‹“å±•é—®é¢˜ï¼‰

    # Depends on:
    1. EasyMath.vecExpand() : expand vectors for those born in laste years of transition path. some years of these men have reached the final steady state
    2. EasyMath.diagr(): read diagonal elements from a matrix, automatically add/drop extra elements
    """
    function DatSlice4Household( t::Int, Dt::Dict, Dst::Dict, Pt::Dict, Ps::Dict, S::Int, Sr::Int ; IsSteadyState::Bool = true )
        local d = Dict{Symbol,Vector{Float64}}()  # use strict type declaration
        # Case 1: for SteadyState ç¨³æ€
        # NOTE: use one year's data (year t) to fill the whole vectors é’ˆå¯¹ç¨³æ€ï¼Œä½¿ç”¨ç‰¹å®šä¸€å¹´çš„å€¼å¡«å……æ•´æ¡è·¯å¾„
        if IsSteadyState
            # -------- len = S
            d[:r] = fill(Dt[:r][t],S) # interest rates
            d[:cpB] = fill(Pt[:cpB][t],S) # co-payment rate of inpatient expenditure
            d[:q] = fill(Pt[:q][t],S) # m2c ratio
            d[:p] = Ps[:p][1:S] # MA/MB ratio
            d[:F] = Ps[:F][t,1:S] # mortality
            # -------- len = Sr
            d[:Ï•] = fill(Pt[:Ï•][t],Sr) # contribution: agent â†’ UEBMI
            d[:Î¶] = fill(Pt[:Î¶][t],Sr) # contribution: firm â†’ UEBMI
            d[:Î·] = fill(Pt[:Î·][t],Sr) # contribution: firm â†’ pension
            d[:Î¸] = fill(Pt[:Î¸][t],Sr) # contribution: agent â†’ pension
            d[:z] = fill(Pt[:z][t],Sr) # collection rate of pension
            d[:ğ•’] = fill(Pt[:ğ•’][t],Sr) # transfer rate from firm contribution of UEBMI to working agents
            d[:w] = Dst[:w][t,1:Sr] # wage level
            # -------- len = S - Sr
            d[:Î›] = fill(Dt[:Î›][t],S-Sr) # pension benefit amounts
            d[:ğ•¡] = fill(Dt[:ğ•¡][t],S-Sr) # transfer amounts from firm contribution of UEBMI to retired generations
        else
        # Case 2: for those born on transition path ä¸ºé‚£äº›åœ¨è½¬è½¨è·¯å¾„ä¸Šå‡ºç”Ÿçš„äºº
        # NOTE: just use "end" keyword to get a uniform grammer for different cases, vecExpand() will delete extra elements if too-long & add extra elements if too-short
        # NOTE: some data in Ps & Dst requires diagonally read; however, pls note we cannot simply repeat the last element (final steady state distribution)
            # -------- len = S
            d[:r] = vecExpand(Dt[:r][t:end], S) # interest rates
            d[:cpB] = vecExpand(Pt[:cpB][t:end], S) # co-payment rate of inpatient expenditure
            d[:q] = vecExpand(Pt[:q][t:end], S) # m2c ratio
            d[:p] = Ps[:p][1:S] # MA/MB ratio
            d[:F] = diagr(Ps[:F], offset = 1 - t , LEN = S) # mortality, automatically handle the case of touching the last row
            # -------- len = Sr
            d[:Ï•] = vecExpand(Pt[:Ï•][t:end], Sr) # contribution: agent â†’ UEBMI
            d[:Î¶] = vecExpand(Pt[:Î¶][t:end], Sr) # contribution: firm â†’ UEBMI
            d[:Î·] = vecExpand(Pt[:Î·][t:end], Sr) # contribution: firm â†’ pension
            d[:Î¸] = vecExpand(Pt[:Î¸][t:end], Sr) # contribution: agent â†’ pension
            d[:z] = vecExpand(Pt[:z][t:end], Sr) # collection rate of pension
            d[:ğ•’] = vecExpand(Pt[:ğ•’][t:end], Sr) # transfer rate from firm contribution of UEBMI to working agents
            d[:w] = diagr(Dst[:w], offset = 1 - t, LEN = Sr) # wage level
            # -------- len = S - Sr
            d[:Î›] = vecExpand(Dt[:Î›][t:end], S-Sr) # pension benefit amounts
            d[:ğ•¡] = vecExpand(Dt[:ğ•¡][t:end], S-Sr) # transfer amounts from firm contribution of UEBMI to retired generations
        end
        # return
        return d::Dict
    end

    # -------------------------------------------------
    """
        SteadyState!( t::Int, Guess::NamedTuple, Dt::Dict, Dst::Dict, env::NamedTuple, Pt::Dict, Ps::Dict, Pc::Dict ; atol::Float64 = 1E-8, MaxIter::Int = 100, PrintMode::String = "full", MagicNum::Real = 2.0, StepLen::Real = 0.5 )

    Searches steady state on a specific **t** slice, using guesses of interest rate & labor (**Guess**);
    the results will be directly/in-place written in data collections (**Dt**, **Dst**);
    returns nothing.

    ## Inputs:
    1. t : the year to search steady state on, it should be less than or equal to *env.MAX_YEAR*
    2. Guess : a NamedTuple consisting of two elements: ( r = interest rate in digits, L = labor factor )
    3. Dt : a data collection to modify/write, containing year data; defined in proc_VarsDeclare
    4. Dst : a data collection to modify/write, containing age Ã— year data; defined in proc_VarsDeclare
    5. env : a parameter collection containing basic parameters like MAX_AGE, RETIRE_AGE and others
    6. Pt : a parameter collection containing year data, won't be modified
    7. Ps : a parameter collection containing age specific data & demographic data (population & mortality); won't be modified
    8. Pc : a parameter collection containing constant data, won't be modified
    9. atol : tolerance of Gauss-Seidel iteration
    10. MaxIter : maximum loops
    11. PrintMode : a string to decide how to display results & loop information
        1. "full" : print all information, including round, error, summary of economy in each round; print a detailed summary when exit
        2. "concise" : print round, error, but no summary of economy for each round; print a detailed summary when ends
        3. "final": print nothing for each round; print a detailed summary when iteration ends
        4. "silent" : nothing printed for each round; nothing printed when iteration ends
    12. MagicNum : a lower bound of capital per labor (K/L) to prevent divergence out of interest rate (a function of capital per labor)
    13. StepLen : relative step length to update guesses of Gauss-Seidel algorithm, in range (0,1]

    ## Modified:
    1. Dt: update economic variables (e.g. GDP, interest rate)
    2. Dst: update consumption, labor and other age-specific data

    ## Iteration Steps:
    1. Firm department
    2. Pension
    3. Household problems
    4. Fiscal, Aggregation & Update

    ## Depends on:
    1.

    """
    function SteadyState!( t::Int, Guess::NamedTuple, Dt::Dict, Dst::Dict,
        env::NamedTuple, Pt::Dict, Ps::Dict, Pc::Dict ;
        atol::Float64 = 1E-8,  # tolerance of Gauss-Seidel iteration
        MaxIter::Int = 100,  # maximum loops
        PrintMode::String = "full",  # mode of printing
        MagicNum::Real = 2.0,  # magic number, the lower bound of K/L (capital per labor)
        StepLen::Real = 0.5  # relative step length to update guesses, in range (0,1]
    )
        ## Section: validation
        @assert( 0 < t <= env.T , string("t not in range [1, ",env.T,"], received :",t) )
        @assert( isa(Guess.r, Real) & (Guess.L >= 0.0), "please check your Guess::NamedTuple" )  # simutaneously check existence of r, L in Guess and their range
        @assert( PrintMode in ["full","concise","final","silent"] , "undefined PrintMode string" )
        @assert( 0.0 < StepLen <= 1.0 , "invalid StepLen, it should be in range (0,1]" )
        @assert( MagicNum > 0.0 , "invalid MagicNum which must be greater than 0" )
        Ps[:F][t,env.S] = 0.0  # forcely refresh mortality in the very last year å¼ºåˆ¶åˆ·æ–°æœ€åä¸€å²çš„æ­»äº¡ç‡ä¸º0
        ## Section: malloc
        local tmpK1::Float64, tmpK2::Float64  # temporary variables of capital factor in iterations
        local tmpL1::Float64, tmpL2::Float64  # temporary variables of labor factor
            tmpL1 = Guess.L  # save the guess of aggregated labor (initialization)
            Dt[:r][t] = Guess.r  # save the guess of interest rate (initialiation)
        ## Section: intermediate variables & abbreviations
        local tmpVal::Float64 = 1.0 + Pt[:z][t] * Pt[:Î·][t] + Pt[:Î¶][t] # a temporary variable
        local Ï€Coef::Float64 = Pt[:z][t] * (Pt[:Î¸][t] + Pt[:Î·][t]) / tmpVal # total contribution to pension (on nomial wage level)
        local Ï€Mf::Float64 = Pt[:Î¶][t] / tmpVal # firm contribution rate to UE-BMI
        local Ï€Mp::Float64 = Pt[:Ï•][t] / tmpVal # employee/personal contribution rate to UE-BMI
        local Ï€M = Ï€Mf + Ï€Mp # total contribution rate to UE-BMI on nomial wage level
        ## Section: fill labor with an even distribution to initialize labor ä½¿ç”¨å¹³å¦çš„åŠ³åŠ¨åŠ›åˆ†å¸ƒå¡«å……ä»¥åˆå§‹åŒ–
        Dst[:Lab][t,1:env.Sr] .= tmpL1 / env.Sr

        ## Section: Gauss-Seidel Iterations
        for idx in 1:MaxIter
            # SubSection 1: firm department å‚å•†éƒ¨é—¨
                # 1. production function & firm optimal decisions ç”Ÿäº§å‡½æ•° & å‚å•†æœ€ä¼˜å†³ç­–
                if idx == 1   # NOTE: use interest rate & labor to get capital in the first round  ç¬¬ä¸€è½®ä½¿ç”¨åˆ©ç‡å’ŒåŠ³åŠ¨åŠ›åæ¨å‡ºèµ„æœ¬å­˜é‡
                    tmpK1 = tmpL1 * ( (Guess.r + Pc[:Îº]) / (Pt[:Î²][t] * Pt[:A][t]) ) ^ (1.0 / (Pt[:Î²][t] - 1.0))
                    @assert( tmpK1 > 0.0 , string("negative K found in round: ", idx) ) # check capital
                    Dt[:Y][t], tmpVal, Dt[:wÌ„][t] = EasyEcon.CDProdFunc( Pt[:A][t], tmpK1, tmpL1, Pt[:Î²][t], Îº = Pc[:Îº], GetPrice = true, TechType = "Hicks"  ) # optimal decision æœ€ä¼˜å†³ç­–ï¼Œè¿”å›ä»·æ ¼
                else
                    Dt[:Y][t], Dt[:r][t], Dt[:wÌ„][t] = EasyEcon.CDProdFunc( Pt[:A][t], tmpK1, tmpL1, Pt[:Î²][t], Îº = Pc[:Îº], GetPrice = true, TechType = "Hicks"  ) # optimal decision æœ€ä¼˜å†³ç­–ï¼Œè¿”å›ä»·æ ¼
                end
                # 2. wage profiling å·¥èµ„æ›²çº¿
                Dst[:w][t,:], Dt[:o][t] = EasyEcon.WageProfile( Dt[:wÌ„][t], Ps[:Îµ][1:env.Sr], Ps[:N][t,1:env.Sr], Dst[:Lab][t,1:env.Sr], GetScalingCoef = true  )
            # SubSection 2: PAYG pension benefits å…»è€é‡‘ç»™ä»˜
                Dt[:Î›][t] = EasyEcon.PAYGPension( Ï€Coef, Dst[:w][t,:], Ps[:N][t,:], Dst[:Lab][t,:], env.Sr )
            # SubSection 3: average transfer amount from firm medical contribution to retired generations å½“æœŸä¼ä¸šåŒ»ä¿ç¼´çº³å¯¹é€€ä¼‘äººå‘˜çš„å¹³å‡è¡¥è´´é‡
                Dt[:ğ•¡][t] = EasyEcon.Getğ•¡( Pt[:ğ•“][t], Ï€Mf, Dst[:w][t,:], Dst[:Lab][t,1:env.Sr], Ps[:N][t,1:env.S], env.Sr )
            # SubSection 4: household lifetime optimization å®¶åº­éƒ¨é—¨ç”Ÿå‘½æœŸæ•ˆç”¨æœ€å¤§åŒ–é—®é¢˜
                # 1. prepare sliced data å‡†å¤‡è¾“å…¥æ•°æ®åˆ‡ç‰‡
                local tmpd = DatSlice4Household(t, Dt,Dst,Pt,Ps,env.S,env.Sr, IsSteadyState = true)  # is steady state, use cross-sectional data to fill paths
                # 2. solve the optimization, get paths (wealth, asset, UEBMI-indi, consumption, leisure) æ±‚è§£ï¼Œå¾—åˆ°è·¯å¾„ï¼ˆè´¢å¯Œã€èµ„äº§ã€ä¸ªäººåŒ»ä¿ã€æ¶ˆè´¹ã€é—²æš‡ï¼‰
                local tmpRet = EasyHousehold.LifeDecision(0.0, 0.0, Pc, tmpd, env.S, env.Sr)
                # 3. distribute results å­˜å‚¨ç»“æœ
                Dst[:ğ’œ][t, 1:env.S] = tmpRet[:ğ’œ] # distribution of wealth (capital)
                Dst[:a][t, 1:env.S] = tmpRet[:a]  # distribution of personal asset accounts
                Dst[:Î¦][t, 1:env.S] = tmpRet[:Î¦]  # distribution of the individual medical accounts of UE-BMI
                Dst[:c][t, 1:env.S] = tmpRet[:c]  # total consumption ç¤¾ä¼šæ€»æ¶ˆè´¹
                Dst[:Lab][t, 1:env.Sr] .= 1.0 .- tmpRet[:l]  # labor supply (converting leisure to labor)
                # 4. other related results å…¶ä»–è¡ç”Ÿçš„ç»“æœ
                Dst[:m][t, 1:env.S] .= tmpRet[:c] .* Pt[:q][t]  # total medical expenditure
                Dst[:MA][t, 1:env.S] .= Dst[:m][t, 1:env.S] .* Ps[:p][1:env.S] ./ (1.0 .+ Ps[:p][1:env.S])  # outpatient expenditure
                Dst[:MB][t, 1:env.S] .= Dst[:m][t, 1:env.S] ./ (1.0 .+ Ps[:p][1:env.S])  # inpatient expenditure
            # SubSection 5: fiscal & UE-BMI è´¢æ”¿ &ã€€UE-BMI
                # 1. tax revenues ç¨æ”¶
                Dt[:TRc][t] = Pc[:Î¼] * sum( Dst[:c][t, 1:env.S]   .* Ps[:N][t,1:env.S] )  # consumption tax æ¶ˆè´¹ç¨
                Dt[:TRw][t] = Pc[:Ïƒ] * sum( Dst[:Lab][t, 1:env.Sr] .* Ps[:N][t,1:env.Sr] .* Dst[:w][t, 1:env.Sr] )  # wage tax å·¥èµ„ç¨
                # 2. the gaps of the social pooling account of UE-BMI (positive for gap, negative for surplus)
                Dt[:LI][t] = sum( ( 1 .- Pt[:cpB][t] .* Dst[:MB][t, 1:env.S] .* Ps[:N][t,1:env.S] ) )
                Dt[:LI][t] -= ( 1 .- Pt[:ğ•’][t] .- Pt[:ğ•“][t] ) .* Pt[:Î¶][t] ./ ( 1 .+ Pt[:Î·][t] + Pt[:Î¶][t] ) .* sum( Ps[:N][t,1:env.Sr] .* Dst[:w][t, 1:env.Sr] .* Dst[:Lab][t, 1:env.Sr] )
            # SubSection 6: update aggregated labor supply æ›´æ–°åŠ³åŠ¨åŠ›ä¾›åº”
                tmpL2 = sum( Ps[:N][t,1:env.Sr] .* Dst[:Lab][t, 1:env.Sr] )
            # SubSection 7: update GDP with the updated labor supply (through production function) ä½¿ç”¨æ›´æ–°çš„åŠ³åŠ¨è¦ç´ æ›´æ–°GDPä¼°è®¡
                Dt[:Y][t] = EasyEcon.CDProdFunc( Pt[:A][t], tmpK1, tmpL2, Pt[:Î²][t], Îº = Pc[:Îº], GetPrice = true, TechType = "Hicks"  )[1]
            # SubSection 8: update updating aggregated capital (K)
                # NOTE: there are two ways to update K: one uses the capital market clearing condition (Method A);
                # and the other one uses the capital growth dynamics (Method B); the two methods are equivalent; and I use Method A here.
                # 1. get aggregated investment (I) through capita dynamics é€šè¿‡èµ„æœ¬åŠ¨æ€æ¡ä»¶å¾—åˆ°æŠ•èµ„
                Dt[:I][t] = tmpK1 * Pc[:Îº]
                # 2. aggregate consumption æ±‡æ€»ç¤¾ä¼šæ€»æ¶ˆè´¹
                Dt[:C][t] = sum( Dst[:c][t, 1:env.S] .* Ps[:N][t,1:env.S] )
                # 3. get government purchase (G) through the good market clearing condition é€šè¿‡å•†å“å¸‚åœºå‡ºæ¸…å¾—åˆ°æ”¿åºœè´­ä¹°
                Dt[:G][t] = Dt[:Y][t] - Dt[:I][t] - Dt[:C][t]
                # 4. get government outstanding debt through the fiscal budget é€šè¿‡æ”¿åºœé¢„ç®—çº¦æŸå¾—åˆ°æ”¿åºœå€ºåŠ¡ä½™é¢
                Dt[:D][t] = ( Dt[:G][t] + Dt[:LI][t] - Dt[:TRc][t] - Dt[:TRw][t] ) / (1 - Dt[:r][t])
                # 5. the upper bound of government outstanding debt æ”¿åºœæœªå¿å€ºåŠ¡è½¯çº¦æŸ
                Dt[:D][t] = max( 0.0, min( Dt[:D][t], Dt[:Y][t] * Pt[:D2Y][t] ) )
                # 6. record the ratio of government outstanding debt on GDP è®°å½•æœªå¿å€ºåŠ¡ä¸GDPçš„æ¯”
                Dt[:D2Y][t] = Dt[:D][t] / Dt[:Y][t]
                # 7. aggregate/update capital æ±‡æ€»/æ›´æ–°ï¼ˆå¹´åˆï¼‰èµ„æœ¬å­˜é‡
                tmpK2 = sum( Dst[:ğ’œ][t, 1:env.S] .* Ps[:N][t,1:env.S] )

            # Convergence check & go to the next loop æ”¶æ•›æ£€æŸ¥
                # 1. compute errors, using a minor number to avoid exact zeros
                local Err = ( K = abs(tmpK2 / (tmpK1 + eps()) ) - 1, L = abs(tmpL2 / (tmpL1 + eps()) ) - 1 )
                # 2. record original K, L
                local OriGuess = [tmpK1, tmpL1]
                # 3. check
                if all(Err .< atol)  # converged
                    # 1. save the converged K, L; using mean values
                    Dt[:K] = ( tmpK1 + tmpK2 ) / 2; Dt[:L] = ( tmpL1 + tmpL2 ) / 2;
                    # 2. print final summary (if not silently solved)
                    if PrintMode != "silent"
                        println("\t+ Status: Converged")  # status
                        println("\t+ Relative Errors: ",Err)  # print error first
                        SummaryYear( t, Dt, Dst, Pt, Ps, S, Sr )  # print the details of the steady state
                    end
                    break  # ends iteration
                elseif idx == MaxIter  # diverged or too few maxmimum rounds set
                    Dt[:K] = ( tmpK1 + tmpK2 ) / 2; Dt[:L] = ( tmpL1 + tmpL2 ) / 2;
                    if PrintMode != "silent"
                        println("\t+ Status: Maximum iteration reached, not converged")
                        println("\t+ Relative Errors: ",Err)
                        SummaryYear( t, Dt, Dst, Pt, Ps, S, Sr )
                    end
                    break  # ends iteration
                else  # go to the next loop
                    # 1. check if the updated labor supply touches the bottom of zero
                    (tmpL2 < 0 || ~isreal(tmpL2))    &&    begin @warn("Labor lower than 0 or complex!"); tmpL2 = 0.01; end
                    # 2. update labor supply
                    tmpL1 += StepLen * (tmpL2 - tmpL1)
                    # 3. use the magic number to set the bottom of capital, which bounds the interest rate in a reasonable range
                    local tmpKfloor = MagicNum * tmpL1
                    # 4. check & update capital supply
                    (tmpK2 < tmpKfloor || ~isreal(tmpK2))    &&    begin @warn("Capital lower than the lower bound or complex!"); tmpK2 = tmpKfloor; end
                    tmpK1 += StepLen * (tmpK2 - tmpK1)
                    # 5. print information, according to :PrintMode
                    if PrintMode in ["full", "concise"]
                        println("\t+ Round: ", idx, "; Relative Errors: ", Err)
                    end
                    if PrintMode == "full"
                        SummaryYear( t, Dt, Dst, Pt, Ps, S, Sr )
                    end
                    # 6. explicitly write continue (as a reminder without practical jobs)
                    continue
                end  # check ends

        end # Gauss-Seidel Iteration ends
        # nomial return
        return nothing
    end  # function ends

    # -----------------------------------------












# ==============================================================================
end  # module ends
#
