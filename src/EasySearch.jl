__precompile__()
"""
    EasySearch

searching steady states & transition path;
concise design;
requires modules/packages in LOAD_PATH
"""
module EasySearch
    import EasyHousehold  # household lifetime optimization
    import EasyEcon  # economic functions
    import EasyMath: vecExpand, diagr  # for DatSlice4Household(), to handle cases that touch final steady state in last years of transition path 用于处理DatSlice4Household()函数中对于处于转轨路径上最后几年出生的人有一段生命落在了最终稳态里的情形，用于为他们加长补全路径


    # ==========================================================================
    """
        SummaryYear( t::Int, Dt::Dict, Dst::Dict, Pt::Dict, Ps::Dict, S::Int, Sr::Int )

    Summarizes a specific cross-sectional; usually used in the summary of steady states;
    It returns nothing but prints to console;
    """
    function SummaryYear( t::Int, Dt::Dict, Dst::Dict, Pt::Dict, Ps::Dict, S::Int, Sr::Int )
        println("\t","."^40, " Factor Markets")
        println("\t+ Aggregated Capital: ", Dt[:K][t] )
        println("\t+ Aggregated Labor  : ", Dt[:L][t] )
        println("\t+ Net Intereste Rate: ", Dt[:r][t] )
        println("\t+ Average Wage Level: ", Dt[:w̄][t] )
        println("\t","-"^40, " Good Market")
        println("\t+ GDP               : ", Dt[:Y][t] )
        println("\t+ C, I, G           : ", [ Dt[:C][t], Dt[:I][t], Dt[:G][t] ]  )
        println("\t+ C, I, G Shares    : ", [ Dt[:C][t], Dt[:I][t], Dt[:G][t] ] ./ (Dt[:Y][t] + eps())  )
        println("\t","."^40, " General Fiscal")
        println("\t+ TaxRev Consumption: ", Dt[:TRc][t] )
        println("\t+ TaxRev Wage Income: ", Dt[:TRw][t] )
        println("\t+ Debt & Debt/GDP   : ", [ Dt[:D][t], Dt[:D2Y][t] ] )
        println("\t","."^40, " PAYG Pension")
        println("\t+ Benefit Amount    : ", Dt[:Λ][t] )
        println("\t+ Substitution Rate : ", Dt[:Λ][t] / (Dt[:w̄][t] * Dt[:L][t] / sum(Ps[:N][t, 1:Sr]) + eps())  )
        println("\t","."^40, " UE-BMI")
        println("\t+ Gap of Pooling Acc: ", Dt[:LI][t] )
        println("\t+ Gap/GDP           : ", Dt[:LI][t] / (Dt[:Y][t] + eps()) )
        println("\t+ Gap/TaxRev        : ", Dt[:LI][t] / (Dt[:TRc][t] + Dt[:TRw][t] + eps()) )
        println("\t","."^40, " Household Department")
        println("\t+ Agg Wealth : ", sum(Ps[:N][t, 1:S] .* Dst[:𝒜][t, 1:S]) )
        println("\t+ Agg Personal Asset: ", sum(Ps[:N][t, 1:S] .* Dst[:a][t, 1:S]) )
        println("\t+ Agg UEBMI Indi-Acc: ", sum(Ps[:N][t, 1:S] .* Dst[:Φ][t, 1:S]) )
        println("\t+ Max Wealth & Loc  : ", findmax(Dst[:𝒜][t, 1:S]) )  # prepared for possible DP, which can help check if DP works well
        println("\t","-"^40)

        return nothing
    end

    # ==========================================================================
    """
        DatSlice4Household( t::Int, Dt::Dict, Dst::Dict, Pt::Dict, Ps::Dict, S::Int, Sr::Int ; IsSteadyState::Bool = true )

    Slices data, generates a Dict **d** for LifeDecision() in EasyHousehold module (just input **Pc** to LifeDecision());
    based on data collections generated by proc_InitPars.jl & proc_VarsDeclare.jl;
    the parameter **IsSS** controls if the slice is for a steady state (if true, use cross-sectional values to fill vectors, if false, use data from year **t** to **t+S**)
    automatically handle the case that there are several years toching possible final steady state;
    returns a Dict **d**.

    用于为稳态、转轨路径的家户最优决策问题切片数据；已经能够自动集中处理各类异常（尤其是touch到最终稳态时的数据拓展问题）

    # Depends on:
    1. EasyMath.vecExpand() : expand vectors for those born in laste years of transition path. some years of these men have reached the final steady state
    2. EasyMath.diagr(): read diagonal elements from a matrix, automatically add/drop extra elements
    """
    function DatSlice4Household( t::Int, Dt::Dict, Dst::Dict, Pt::Dict, Ps::Dict, S::Int, Sr::Int ; IsSteadyState::Bool = true )
        local d = Dict{Symbol,Vector{Float64}}()  # use strict type declaration
        # Case 1: for SteadyState 稳态
        # NOTE: use one year's data (year t) to fill the whole vectors 针对稳态，使用特定一年的值填充整条路径
        if IsSteadyState
            # -------- len = S
            d[:r] = fill(Dt[:r][t],S) # interest rates
            d[:cpB] = fill(Pt[:cpB][t],S) # co-payment rate of inpatient expenditure
            d[:q] = fill(Pt[:q][t],S) # m2c ratio
            d[:p] = Ps[:p][1:S] # MA/MB ratio
            d[:F] = Ps[:F][t,1:S] # mortality
            # -------- len = Sr
            d[:ϕ] = fill(Pt[:ϕ][t],Sr) # contribution: agent → UEBMI
            d[:ζ] = fill(Pt[:ζ][t],Sr) # contribution: firm → UEBMI
            d[:η] = fill(Pt[:η][t],Sr) # contribution: firm → pension
            d[:θ] = fill(Pt[:θ][t],Sr) # contribution: agent → pension
            d[:z] = fill(Pt[:z][t],Sr) # collection rate of pension
            d[:𝕒] = fill(Pt[:𝕒][t],Sr) # transfer rate from firm contribution of UEBMI to working agents
            d[:w] = Dst[:w][t,1:Sr] # wage level
            # -------- len = S - Sr
            d[:Λ] = fill(Dt[:Λ][t],S-Sr) # pension benefit amounts
            d[:𝕡] = fill(Dt[:𝕡][t],S-Sr) # transfer amounts from firm contribution of UEBMI to retired generations
        else
        # Case 2: for those born on transition path 为那些在转轨路径上出生的人
        # NOTE: just use "end" keyword to get a uniform grammer for different cases, vecExpand() will delete extra elements if too-long & add extra elements if too-short
        # NOTE: some data in Ps & Dst requires diagonally read; however, pls note we cannot simply repeat the last element (final steady state distribution)
            # -------- len = S
            d[:r] = vecExpand(Dt[:r][t:end], S) # interest rates
            d[:cpB] = vecExpand(Pt[:cpB][t:end], S) # co-payment rate of inpatient expenditure
            d[:q] = vecExpand(Pt[:q][t:end], S) # m2c ratio
            d[:p] = Ps[:p][1:S] # MA/MB ratio
            d[:F] = diagr(Ps[:F], offset = 1 - t , LEN = S) # mortality, automatically handle the case of touching the last row
            # -------- len = Sr
            d[:ϕ] = vecExpand(Pt[:ϕ][t:end], Sr) # contribution: agent → UEBMI
            d[:ζ] = vecExpand(Pt[:ζ][t:end], Sr) # contribution: firm → UEBMI
            d[:η] = vecExpand(Pt[:η][t:end], Sr) # contribution: firm → pension
            d[:θ] = vecExpand(Pt[:θ][t:end], Sr) # contribution: agent → pension
            d[:z] = vecExpand(Pt[:z][t:end], Sr) # collection rate of pension
            d[:𝕒] = vecExpand(Pt[:𝕒][t:end], Sr) # transfer rate from firm contribution of UEBMI to working agents
            d[:w] = diagr(Dst[:w], offset = 1 - t, LEN = Sr) # wage level
            # -------- len = S - Sr
            d[:Λ] = vecExpand(Dt[:Λ][t:end], S-Sr) # pension benefit amounts
            d[:𝕡] = vecExpand(Dt[:𝕡][t:end], S-Sr) # transfer amounts from firm contribution of UEBMI to retired generations
        end
        # return
        return d::Dict
    end

    # -------------------------------------------------
    """
        SteadyState!( t::Int, Guess::NamedTuple, Dt::Dict, Dst::Dict, env::NamedTuple, Pt::Dict, Ps::Dict, Pc::Dict ; atol::Float64 = 1E-8, MaxIter::Int = 100, PrintMode::String = "full", MagicNum::Real = 2.0, StepLen::Real = 0.5 )

    Searches steady state on a specific **t** slice, using guesses of interest rate & labor (**Guess**);
    the results will be directly/in-place written in data collections (**Dt**, **Dst**);
    returns nothing.

    ## Inputs:
    1. t : the year to search steady state on, it should be less than or equal to *env.MAX_YEAR*
    2. Guess : a NamedTuple consisting of two elements: ( r = interest rate in digits, L = labor factor )
    3. Dt : a data collection to modify/write, containing year data; defined in proc_VarsDeclare
    4. Dst : a data collection to modify/write, containing age × year data; defined in proc_VarsDeclare
    5. env : a parameter collection containing basic parameters like MAX_AGE, RETIRE_AGE and others
    6. Pt : a parameter collection containing year data, won't be modified
    7. Ps : a parameter collection containing age specific data & demographic data (population & mortality); won't be modified
    8. Pc : a parameter collection containing constant data, won't be modified
    9. atol : tolerance of Gauss-Seidel iteration
    10. MaxIter : maximum loops
    11. PrintMode : a string to decide how to display results & loop information
        1. "full" : print all information, including round, error, summary of economy in each round; print a detailed summary when exit
        2. "concise" : print round, error, but no summary of economy for each round; print a detailed summary when ends
        3. "final": print nothing for each round; print a detailed summary when iteration ends
        4. "silent" : nothing printed for each round; nothing printed when iteration ends
    12. MagicNum : a lower bound of capital per labor (K/L) to prevent divergence out of interest rate (a function of capital per labor)
    13. StepLen : relative step length to update guesses of Gauss-Seidel algorithm, in range (0,1]

    ## Modified:
    1. Dt: update economic variables (e.g. GDP, interest rate)
    2. Dst: update consumption, labor and other age-specific data

    ## Iteration Steps:
    1. Firm department
    2. Pension
    3. Household problems
    4. Fiscal, Aggregation & Update

    ## Depends on:
    1.

    """
    function SteadyState!( t::Int, Guess::NamedTuple, Dt::Dict, Dst::Dict,
        env::NamedTuple, Pt::Dict, Ps::Dict, Pc::Dict ;
        atol::Float64 = 1E-8,  # tolerance of Gauss-Seidel iteration
        MaxIter::Int = 100,  # maximum loops
        PrintMode::String = "full",  # mode of printing
        MagicNum::Real = 2.0,  # magic number, the lower bound of K/L (capital per labor)
        StepLen::Real = 0.5  # relative step length to update guesses, in range (0,1]
    )
        ## Section: validation
        @assert( 0 < t <= env.T , string("t not in range [1, ",env.T,"], received :",t) )
        @assert( isa(Guess.r, Real) & (Guess.L >= 0.0), "please check your Guess::NamedTuple" )  # simutaneously check existence of r, L in Guess and their range
        @assert( PrintMode in ["full","concise","final","silent"] , "undefined PrintMode string" )
        @assert( 0.0 < StepLen <= 1.0 , "invalid StepLen, it should be in range (0,1]" )
        @assert( MagicNum > 0.0 , "invalid MagicNum which must be greater than 0" )
        Ps[:F][t,env.S] = 0.0  # forcely refresh mortality in the very last year 强制刷新最后一岁的死亡率为0
        ## Section: malloc
        local tmpK1::Float64, tmpK2::Float64  # temporary variables of capital factor in iterations
        local tmpL1::Float64, tmpL2::Float64  # temporary variables of labor factor
            tmpL1 = Guess.L  # save the guess of aggregated labor (initialization)
            Dt[:r][t] = Guess.r  # save the guess of interest rate (initialiation)
        ## Section: intermediate variables & abbreviations
        local tmpVal::Float64 = 1.0 + Pt[:z][t] * Pt[:η][t] + Pt[:ζ][t] # a temporary variable
        local πCoef::Float64 = Pt[:z][t] * (Pt[:θ][t] + Pt[:η][t]) / tmpVal # total contribution to pension (on nomial wage level)
        local πMf::Float64 = Pt[:ζ][t] / tmpVal # firm contribution rate to UE-BMI
        local πMp::Float64 = Pt[:ϕ][t] / tmpVal # employee/personal contribution rate to UE-BMI
        local πM = πMf + πMp # total contribution rate to UE-BMI on nomial wage level
        ## Section: fill labor with an even distribution to initialize labor 使用平坦的劳动力分布填充以初始化
        Dst[:Lab][t,1:env.Sr] .= tmpL1 / env.Sr

        ## Section: Gauss-Seidel Iterations
        for idx in 1:MaxIter
            # SubSection 1: firm department 厂商部门
                # 1. production function & firm optimal decisions 生产函数 & 厂商最优决策
                if idx == 1   # NOTE: use interest rate & labor to get capital in the first round  第一轮使用利率和劳动力反推出资本存量
                    tmpK1 = tmpL1 * ( (Guess.r + Pc[:κ]) / (Pt[:β][t] * Pt[:A][t]) ) ^ (1.0 / (Pt[:β][t] - 1.0))
                    @assert( tmpK1 > 0.0 , string("negative K found in round: ", idx) ) # check capital
                    Dt[:Y][t], tmpVal, Dt[:w̄][t] = EasyEcon.CDProdFunc( Pt[:A][t], tmpK1, tmpL1, Pt[:β][t], κ = Pc[:κ], GetPrice = true, TechType = "Hicks"  ) # optimal decision 最优决策，返回价格
                else
                    Dt[:Y][t], Dt[:r][t], Dt[:w̄][t] = EasyEcon.CDProdFunc( Pt[:A][t], tmpK1, tmpL1, Pt[:β][t], κ = Pc[:κ], GetPrice = true, TechType = "Hicks"  ) # optimal decision 最优决策，返回价格
                end
                # 2. wage profiling 工资曲线
                Dst[:w][t,:], Dt[:o][t] = EasyEcon.WageProfile( Dt[:w̄][t], Ps[:ε][1:env.Sr], Ps[:N][t,1:env.Sr], Dst[:Lab][t,1:env.Sr], GetScalingCoef = true  )
            # SubSection 2: PAYG pension benefits 养老金给付
                Dt[:Λ][t] = EasyEcon.PAYGPension( πCoef, Dst[:w][t,:], Ps[:N][t,:], Dst[:Lab][t,:], env.Sr )
            # SubSection 3: average transfer amount from firm medical contribution to retired generations 当期企业医保缴纳对退休人员的平均补贴量
                Dt[:𝕡][t] = EasyEcon.Get𝕡( Pt[:𝕓][t], πMf, Dst[:w][t,:], Dst[:Lab][t,1:env.Sr], Ps[:N][t,1:env.S], env.Sr )
            # SubSection 4: household lifetime optimization 家庭部门生命期效用最大化问题
                # 1. prepare sliced data 准备输入数据切片
                local tmpd = DatSlice4Household(t, Dt,Dst,Pt,Ps,env.S,env.Sr, IsSteadyState = true)  # is steady state, use cross-sectional data to fill paths
                # 2. solve the optimization, get paths (wealth, asset, UEBMI-indi, consumption, leisure) 求解，得到路径（财富、资产、个人医保、消费、闲暇）
                local tmpRet = EasyHousehold.LifeDecision(0.0, 0.0, Pc, tmpd, env.S, env.Sr)
                # 3. distribute results 存储结果
                Dst[:𝒜][t, 1:env.S] = tmpRet[:𝒜] # distribution of wealth (capital)
                Dst[:a][t, 1:env.S] = tmpRet[:a]  # distribution of personal asset accounts
                Dst[:Φ][t, 1:env.S] = tmpRet[:Φ]  # distribution of the individual medical accounts of UE-BMI
                Dst[:c][t, 1:env.S] = tmpRet[:c]  # total consumption 社会总消费
                Dst[:Lab][t, 1:env.Sr] .= 1.0 .- tmpRet[:l]  # labor supply (converting leisure to labor)
                # 4. other related results 其他衍生的结果
                Dst[:m][t, 1:env.S] .= tmpRet[:c] .* Pt[:q][t]  # total medical expenditure
                Dst[:MA][t, 1:env.S] .= Dst[:m][t, 1:env.S] .* Ps[:p][1:env.S] ./ (1.0 .+ Ps[:p][1:env.S])  # outpatient expenditure
                Dst[:MB][t, 1:env.S] .= Dst[:m][t, 1:env.S] ./ (1.0 .+ Ps[:p][1:env.S])  # inpatient expenditure
            # SubSection 5: fiscal & UE-BMI 财政 &　UE-BMI
                # 1. tax revenues 税收
                Dt[:TRc][t] = Pc[:μ] * sum( Dst[:c][t, 1:env.S]   .* Ps[:N][t,1:env.S] )  # consumption tax 消费税
                Dt[:TRw][t] = Pc[:σ] * sum( Dst[:Lab][t, 1:env.Sr] .* Ps[:N][t,1:env.Sr] .* Dst[:w][t, 1:env.Sr] )  # wage tax 工资税
                # 2. the gaps of the social pooling account of UE-BMI (positive for gap, negative for surplus)
                Dt[:LI][t] = sum( ( 1 .- Pt[:cpB][t] .* Dst[:MB][t, 1:env.S] .* Ps[:N][t,1:env.S] ) )
                Dt[:LI][t] -= ( 1 .- Pt[:𝕒][t] .- Pt[:𝕓][t] ) .* Pt[:ζ][t] ./ ( 1 .+ Pt[:η][t] + Pt[:ζ][t] ) .* sum( Ps[:N][t,1:env.Sr] .* Dst[:w][t, 1:env.Sr] .* Dst[:Lab][t, 1:env.Sr] )
            # SubSection 6: update aggregated labor supply 更新劳动力供应
                tmpL2 = sum( Ps[:N][t,1:env.Sr] .* Dst[:Lab][t, 1:env.Sr] )
            # SubSection 7: update GDP with the updated labor supply (through production function) 使用更新的劳动要素更新GDP估计
                Dt[:Y][t] = EasyEcon.CDProdFunc( Pt[:A][t], tmpK1, tmpL2, Pt[:β][t], κ = Pc[:κ], GetPrice = true, TechType = "Hicks"  )[1]
            # SubSection 8: update updating aggregated capital (K)
                # NOTE: there are two ways to update K: one uses the capital market clearing condition (Method A);
                # and the other one uses the capital growth dynamics (Method B); the two methods are equivalent; and I use Method A here.
                # 1. get aggregated investment (I) through capita dynamics 通过资本动态条件得到投资
                Dt[:I][t] = tmpK1 * Pc[:κ]
                # 2. aggregate consumption 汇总社会总消费
                Dt[:C][t] = sum( Dst[:c][t, 1:env.S] .* Ps[:N][t,1:env.S] )
                # 3. get government purchase (G) through the good market clearing condition 通过商品市场出清得到政府购买
                Dt[:G][t] = Dt[:Y][t] - Dt[:I][t] - Dt[:C][t]
                # 4. get government outstanding debt through the fiscal budget 通过政府预算约束得到政府债务余额
                Dt[:D][t] = ( Dt[:G][t] + Dt[:LI][t] - Dt[:TRc][t] - Dt[:TRw][t] ) / (1 - Dt[:r][t])
                # 5. the upper bound of government outstanding debt 政府未偿债务软约束
                Dt[:D][t] = max( 0.0, min( Dt[:D][t], Dt[:Y][t] * Pt[:D2Y][t] ) )
                # 6. record the ratio of government outstanding debt on GDP 记录未偿债务与GDP的比
                Dt[:D2Y][t] = Dt[:D][t] / Dt[:Y][t]
                # 7. aggregate/update capital 汇总/更新（年初）资本存量
                tmpK2 = sum( Dst[:𝒜][t, 1:env.S] .* Ps[:N][t,1:env.S] )

            # Convergence check & go to the next loop 收敛检查
                # 1. compute errors, using a minor number to avoid exact zeros
                local Err = ( K = abs(tmpK2 / (tmpK1 + eps()) ) - 1, L = abs(tmpL2 / (tmpL1 + eps()) ) - 1 )
                # 2. record original K, L
                local OriGuess = [tmpK1, tmpL1]
                # 3. check
                if all(Err .< atol)  # converged
                    # 1. save the converged K, L; using mean values
                    Dt[:K] = ( tmpK1 + tmpK2 ) / 2; Dt[:L] = ( tmpL1 + tmpL2 ) / 2;
                    # 2. print final summary (if not silently solved)
                    if PrintMode != "silent"
                        println("\t+ Status: Converged")  # status
                        println("\t+ Relative Errors: ",Err)  # print error first
                        SummaryYear( t, Dt, Dst, Pt, Ps, S, Sr )  # print the details of the steady state
                    end
                    break  # ends iteration
                elseif idx == MaxIter  # diverged or too few maxmimum rounds set
                    Dt[:K] = ( tmpK1 + tmpK2 ) / 2; Dt[:L] = ( tmpL1 + tmpL2 ) / 2;
                    if PrintMode != "silent"
                        println("\t+ Status: Maximum iteration reached, not converged")
                        println("\t+ Relative Errors: ",Err)
                        SummaryYear( t, Dt, Dst, Pt, Ps, S, Sr )
                    end
                    break  # ends iteration
                else  # go to the next loop
                    # 1. check if the updated labor supply touches the bottom of zero
                    (tmpL2 < 0 || ~isreal(tmpL2))    &&    begin @warn("Labor lower than 0 or complex!"); tmpL2 = 0.01; end
                    # 2. update labor supply
                    tmpL1 += StepLen * (tmpL2 - tmpL1)
                    # 3. use the magic number to set the bottom of capital, which bounds the interest rate in a reasonable range
                    local tmpKfloor = MagicNum * tmpL1
                    # 4. check & update capital supply
                    (tmpK2 < tmpKfloor || ~isreal(tmpK2))    &&    begin @warn("Capital lower than the lower bound or complex!"); tmpK2 = tmpKfloor; end
                    tmpK1 += StepLen * (tmpK2 - tmpK1)
                    # 5. print information, according to :PrintMode
                    if PrintMode in ["full", "concise"]
                        println("\t+ Round: ", idx, "; Relative Errors: ", Err)
                    end
                    if PrintMode == "full"
                        SummaryYear( t, Dt, Dst, Pt, Ps, S, Sr )
                    end
                    # 6. explicitly write continue (as a reminder without practical jobs)
                    continue
                end  # check ends

        end # Gauss-Seidel Iteration ends
        # nomial return
        return nothing
    end  # function ends

    # -----------------------------------------












# ==============================================================================
end  # module ends
#
